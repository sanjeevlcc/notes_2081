




Unit 3. Processes 6 Hrs.
    3.1 Threads
    3.2 Virtualization
    3.3 Clients
    3.4 Servers
    3.5 Code Migration
























======================================================================
Processes
======================================================================

  A process is an instance of a program in execution. 
  It contains the program code and its activity, including the
  current state, register contents, and variables.
  
  A process is an independent entity to which system
  resources (CPU time, memory, etc.) are allocated.



  Use Case:
  -----------
    Running an application on an operating system, 
    such as a word processor or a web browser.
    
    Executing system-level tasks like background 
    services or scheduled jobs.
  




  Advantages:
  ---------------
      Processes provide isolation, ensuring that one process 
      does not interfere with the memory or resources of another.
      
      They allow multitasking, enabling multiple programs
      to run simultaneously on a system.
      
      Processes can run in parallel on multi-core processors, 
      improving performance and efficiency.


  Disadvantages:
  -------------
      Creating and managing processes involves overhead, such
      as memory usage for process control blocks (PCBs) and context switching.
      
      Inter-process communication (IPC) can be complex and
      slower compared to communication within the same process (e.g., threads).
      
      Processes are more heavyweight compared to
      threads, leading to higher resource consumption.
  


  Features:
  ---------------
      Process Control Block (PCB): Contains process state, 
      program counter, CPU registers, memory management information, and I/O status.
      
      Memory Management: Processes have their own address space, 
      including the code segment, data segment, and stack segment.
      
      Process States: New, Ready, Running, Waiting, Terminated.
      
      Context Switching: The process of storing and restoring the 
      state of a CPU so that multiple processes can share a single CPU resource.
      









Linux Terminal Commands
--------------------------


controlplane $ ps -e
    PID TTY          TIME CMD
      1 ?        00:00:07 systemd
      2 ?        00:00:00 kthreadd
      3 ?        00:00:00 rcu_gp
      4 ?        00:00:00 rcu_par_gp
      6 ?        00:00:00 kworker/0:0H-events_highpri
      8 ?        00:00:00 mm_percpu_wq





controlplane $ ps aux
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root           1  0.1  0.4 168524  9492 ?        Ss   22:28   0:07 /sbin/init
root           2  0.0  0.0      0     0 ?        S    22:28   0:00 [kthreadd]
root           3  0.0  0.0      0     0 ?        I<   22:28   0:00 [rcu_gp]








controlplane $ top
top - 23:47:33 up  1:19,  0 users,  load average: 0.14, 0.15, 0.10
Tasks: 202 total,   2 running, 200 sleeping,   0 stopped,   0 zombie
%Cpu(s):  2.7 us,  3.1 sy,  0.0 ni, 92.2 id,  1.7 wa,  0.0 hi,  0.0 si,  0.3 st
MiB Mem :   1983.3 total,     82.0 free,    958.2 used,    943.1 buff/cache
MiB Swap:      0.0 total,      0.0 free,      0.0 used.    831.2 avail Mem 

    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                                                       
   2142 root      20   0 1541180 247812  38352 S   2.7  12.2   2:08.40 kube-apiserver                                                
   1696 root      20   0 1927964  67364  31896 S   0.7   3.3   0:44.47 kubelet                                                       
   2107 root      20   0   10.7g  65488  18536 R   0.7   3.2   0:46.31 etcd     




controlplane $ pstree
systemd-+-ModemManager---2*[{ModemManager}]
        |-NetworkManager---2*[{NetworkManager}]
        |-accounts-daemon---2*[{accounts-daemon}]
        |-agent---2*[{agent}]
        |-agetty
        |-at-spi-bus-laun-+-dbus-daemon



controlplane $ sudo apt-get install htop

controlplane $ htop










======================================================================
3.1 Threads
======================================================================


    A thread is the smallest unit of a process that 
    can be scheduled and executed by the CPU.
    
    Threads within the same process share resources 
    such as memory and file descriptors but execute independently.
    
    Threads allow a program to perform multiple tasks 
    concurrently, improving the efficiency and responsiveness of applications.





Use Case:
-----------
    Web Servers: Using threads to handle multiple simultaneous client requests.
    
    GUI Applications: Running the user interface on one thread 
                      while performing background tasks on another to keep 
                      the application responsive.
    
    Real-time Systems: Performing time-critical tasks in separate
                        threads to ensure timely execution.






Example:
----------
Web Browser: Separate threads handle rendering, downloading, and user input.

Word Processor: One thread manages the document interface while another
                performs background spell-checking.







Advantages:
-----------------
    Improved Performance: 
      Threads can run concurrently on multiple processors, 
      utilizing CPU resources more efficiently.
      
    Resource Sharing: 
      Threads within the same process share memory and 
      other resources, reducing overhead compared to processes.
    
    Responsiveness:
      Multithreaded applications can remain responsive
      to user input while performing other tasks in the background.




Disadvantages:
-------------------
    Complexity: 
      Multithreading introduces complexity in synchronization
      and coordination between threads.
    
    Concurrency Issues: 
      Risks of race conditions, deadlocks, and other
      synchronization problems.
    
    Debugging Challenges:
      Difficulties in identifying and resolving issues
      due to concurrent execution.
    



Features:
-----------
      Shared Memory Space: 
        Threads share the same address space, enabling 
        efficient communication and data sharing.
      
      Independent Execution: 
        Each thread has its own program counter,
        stack, and set of registers.
      
      Lightweight: 
        Threads have less overhead compared to processes, 
        making them more efficient for parallel execution.
      
      
      Synchronization Mechanisms: 
        Tools like mutexes, semaphores, and condition variables are 
        used to manage access to shared resources and coordinate thread execution.














Linux Terminal Commands
--------------------------

  
controlplane $ ps -eL                    #List threads for all processes:


    PID     LWP TTY          TIME CMD
      1       1 ?        00:00:08 systemd
      2       2 ?        00:00:00 kthreadd
      3       3 ?        00:00:00 rcu_gp
      4       4 ?        00:00:00 rcu_par_gp
      6       6 ?        00:00:00 kworker/0:0H-events_highpri
      8       8 ?        00:00:00 mm_percpu_wq
      9       9 ?        00:00:01 ksoftirqd/0
     10      10 ?        00:00:00 rcu_sched





controlplane $ sudo apt-get install nginx -y

controlplane $ sudo systemctl start nginx

controlplane $ pgrep nginx                  #Find the Process ID (PID) of Nginx
17257
17258



controlplane $ ps -T -p 17257            #List Threads of a Specific Nginx Process
    PID    SPID TTY          TIME CMD
  17257   17257 ?        00:00:00 nginx


controlplane $ ps -T -p 17258            #List Threads of a Specific Nginx Process
    PID    SPID TTY          TIME CMD
  17258   17258 ?        00:00:00 nginx



controlplane $ ps -eL | grep nginx            #to list all threads for all Nginx processes:
  17257   17257 ?        00:00:00 nginx
  17258   17258 ?        00:00:00 nginx
















======================================================================
3.2 Virtualization
======================================================================

            
                Virtualization is the creation of a virtual version of a 
                physical resource, such as a server, storage device, 
                network, or even an entire operating system.
                
                
                It allows multiple virtual environments to run on a single
                physical hardware resource, improving resource utilization and 
                providing flexibility in managing IT infrastructure.
                
            
            
            
            
            Use Case:
            ---------------
                Server Consolidation: 
                ----------------------
                  Running multiple virtual servers on a single 
                  physical server to maximize resource utilization.
                  
                
                Development and Testing:
                ----------------------
                  Creating isolated environments for development 
                  and testing without affecting the production environment.
                
                
                Disaster Recovery: 
                ----------------------
                  Using virtual machines (VMs) for backup and 
                  recovery, enabling quick restoration of services.
            
            
            
            
            
            Example:
            ---------------
                Using VMware or VirtualBox to run multiple
                operating systems (e.g., Windows, Linux) on a single physical machine.
                
                
                Employing Docker to create and manage containers for 
                microservices architecture.
            
            
            
            
            
            
            
            
            Advantages:
            ---------------
                  Resource Efficiency: 
                      Maximizes the use of physical hardware by running multiple virtual machines.
                  
                  
                  Isolation:
                      Each virtual machine or container is isolated, enhancing security and stability.
                  
                  
                  Scalability: 
                      Easily scale resources up or down by adding or removing virtual machines or containers.
            
            
                  Flexibility: 
                      Quickly provision and deploy new environments as needed.
                  
            
            
            
            
            Disadvantages:
            ---------------
                  Performance Overhead: 
                      Virtualization introduces a layer of abstraction, which can lead
                      to performance overhead compared to running directly on physical hardware.
                      
                  
                  Complexity:
                      Managing a virtualized environment can be complex, 
                      requiring specialized skills and tools.
                  
                  
                  Security Risks:
                      If the virtualization layer is compromised, all virtual
                      machines or containers running on it could be affected.
                      
            
            
            Features:
            ---------------
                  
                  Hypervisors: 
                      Software that creates and manages virtual machines by 
                      abstracting the hardware. There are two types:
            
                          Type 1 (Bare-metal):   
                                                Runs directly on the 
                                                physical hardware (e.g., VMware ESXi, Microsoft Hyper-V).
                          Type 2 (Hosted): 
                                                Runs on a host operating 
                                                system (e.g., VMware Workstation, Oracle VirtualBox).
                  
                  Virtual Machines (VMs): 
                      Independent instances of operating systems running on virtualized hardware.
            
            
                  Containers: 
                      Lightweight, portable units of software that include the
                      application and its dependencies, running on a shared OS kernel (e.g., Docker, Kubernetes).
            
            
                  Snapshot and Cloning:
                      Features that allow capturing the state of a VM
                      or container at a specific point in time and creating duplicates.
                  
                  Resource Allocation:
                      Ability to allocate and manage CPU, memory, storage, 
                      and network resources for virtual environments.
                  
            
            
            Detailed Explanation of Features:
            ------------------------------------
                1. Hypervisors:
                ---------------
                    Type 1 (Bare-metal) Hypervisors:
                    ---------------
                        Runs directly on the physical hardware without an underlying operating system.
                        Provides high performance and efficiency.
                        Examples: VMware ESXi, Microsoft Hyper-V, XenServer.
                    
                    
                    Type 2 (Hosted) Hypervisors:
                    ---------------
                        Runs on top of an existing operating system, 
                        providing a layer for creating and managing VMs.
                    
                        Easier to set up and use, suitable for desktops and non-enterprise environments.
                    
                        Examples: VMware Workstation, Oracle VirtualBox, Parallels Desktop.
                
                
                2. Virtual Machines (VMs):
                ---------------
                    Complete emulations of physical computers, running
                    their own operating systems and applications.
                    
                    Each VM is isolated, with its own virtual hardware, 
                    including CPU, memory, storage, and network interfaces.
                    
                    Useful for running multiple operating systems on a single
                    physical machine and for creating isolated environments
                    for different applications.
                
                
                3. Containers:
                ---------------
                    Lightweight and portable units of software that
                    package an application and its dependencies together.
                    
                    
                    Containers share the host operating system kernel, making
                    them more efficient and faster to start than VMs.
                    
                    
                    Ideal for microservices architecture, allowing developers to 
                    build, ship, and run applications consistently across environments.
                    
                    Examples: Docker, Kubernetes.
                
                
                4. Snapshot and Cloning:
                -----------------------
                  Snapshots: 
                      Capture the state of a VM or container at a specific 
                      point in time, allowing quick restoration to that state if needed.
                      
                  
                  Cloning: 
                      Create exact copies of VMs or containers, useful for 
                      testing, development, or scaling applications.
                
                
                5. Resource Allocation:
                ------------------------
                    Virtualization platforms provide tools to allocate and
                    manage resources such as CPU, memory, storage, and network 
                    bandwidth to VMs and containers.
                    
                    Enables efficient use of physical hardware by dynamically 
                    adjusting resource allocation based on workload demands.
            
            
            
            
            
            
            
            
            Practical Considerations:
            -------------------------------
            
                  Performance Optimization:
                  ---------------
                        Use hardware with virtualization support 
                        (e.g., Intel VT-x, AMD-V) to reduce performance overhead.
                        
                        Optimize resource allocation to ensure that VMs and 
                        containers have sufficient resources without over-provisioning.
                  
                  Security:
                  ---------------
                        Implement strong security measures for the 
                        virtualization layer, such as regular updates, patches, and monitoring.
                        
                        Use isolation techniques to prevent one compromised
                        VM or container from affecting others.
                  
                  
                  Management Tools:
                  ---------------
                        Utilize management tools and platforms 
                        (e.g., VMware vSphere, Red Hat OpenShift) to simplify the 
                        administration and orchestration of virtual environments.
                        
                        
                        Automate common tasks like deployment, scaling, and 
                        monitoring to improve efficiency and reduce manual intervention.
                        
                  
                  
                  Backup and Recovery:
                  ---------------
                        Regularly back up VMs and containers to 
                        ensure quick recovery in case of failure.
                        
                        
                        Use snapshots and cloning to create consistent 
                        backup points and streamline the recovery process.
                        
            
            


======================================================================
3.3 Clients
======================================================================

        A client is a software or hardware component 
        hat accesses services provided by a server.
        
        Clients request data or services from servers, which
        then process the requests and return the appropriate responses.
        
        
        
        
        Use Case:
        ------------
            Accessing websites through web browsers.
            
            Retrieving and sending emails using email clients.
            
            Connecting to a database to query or update information.
        
        
        Example:
        ------------
                Web Browsers:
                    Chrome, Firefox, Safari, which access and
                    display web pages from web servers.
                
                Email Clients: 
                    Outlook, Thunderbird, which manage sending
                    and receiving emails from mail servers.
                
                Database Clients: 
                    SQL*Plus, MySQL Workbench, which interact 
                    with database servers to manage data.
        
        
        
        
        Advantages:
        ------------
                
                User-Friendly Interfaces: 
                    Clients often provide graphical or command-line 
                    interfaces that make it easier for users to interact with servers.
                
                Resource Efficiency: 
                    Clients offload processing tasks to servers, requiring
                    less computational power and storage.
                
                Scalability:
                    Multiple clients can access a server simultaneously, allowing
                    services to scale according to demand.
                    
        
        
        
        Disadvantages:
        ----------------
                Dependency on Servers: 
                    Clients rely on the availability and performance 
                    of servers. If the server is down, the client cannot function.
                
                Security Risks: 
                    Communication between clients and
                    servers must be secured to prevent data breaches or unauthorized access.
                
                Limited Control: 
                    Clients have limited control over 
                    server-side resources and configurations.
        
        
        
        
        Features:
        ----------------
        
        
        User Interface:
        ---------------------
            Provides a way for users to interact with the 
            server's services, either through a GUI (graphical user interface)
            or CLI (command-line interface).
        
        
                Graphical User Interface (GUI): 
                ---------------------------------
                    Provides visual elements like windows, icons, and 
                    buttons that users interact with to access server services. 
                    
                    Examples include web browsers and desktop applications.
                
                Command-Line Interface (CLI):
                -------------------------------
                    Offers a text-based interface where users input
                    commands to perform operations. 
                    
                    Examples include terminal applications like SSH clients
                    or database command-line tools.
        
        
        Network Communication:
        -----------------------
            Handles the transmission of requests and 
            responses over a network using protocols like HTTP, FTP, or SMTP.
            
            
                Protocols:
                -----------
                    Defines the rules and conventions for communication 
                    between clients and servers.
            
                    Common protocols include:
                            HTTP/HTTPS: For web communication.
                            FTP: For file transfers.
                            SMTP/IMAP/POP3: For email communication.
                
                Request-Response Model:
                ---------------------
                    Clients send requests to servers, which process
                    the requests and send back responses. 
                    This model is fundamental to client-server architecture.
                    
        
        Session Management:
        -----------------------
            Maintains the state of interactions with the server, ensuring 
            continuity and coherence in multi-step operations.
            
        
                State Maintenance: 
                ---------------------
                    Clients often need to maintain the state of their
                    interactions with servers across multiple requests. 
                    
                    For example, a web browser maintains session cookies to keep a user logged in.
                
                Session Storage: 
                -----------------
                    Can be managed on the client 
                    side (e.g., cookies, local storage) or server side (e.g., session IDs stored in a database).
                
        
        Error Handling:
        ------------------
        Manages errors and exceptions that occur during
        communication with the server, providing feedback 
        to the user and retry mechanisms.
        
                Retry Mechanisms: 
                -------------------
                    Clients may implement retry logic to handle transient
                    errors, such as network timeouts or temporary server unavailability.
                
                User Feedback:
                ---------------
                    Provides informative error messages 
                    to the user, explaining issues like network errors, 
                    authentication failures, or unavailable services.
                    
        
        


======================================================================
3.4 Servers
======================================================================


A server is a computer system or software application 
that provides services, resources, or data to clients over a network.

Servers respond to requests from clients and perform
tasks such as data storage, processing, and serving web pages.





Use Case:
---------------
    Web Hosting: 
    -------------------
        Serving web pages and applications to 
        users over the internet.
    
    Database Management: 
    -------------------
        Storing, retrieving, and 
        managing data for applications.
    
    File Sharing: 
    -------------------
        Providing a centralized location for
        storing  and sharing files among multiple users.




Example:
-------------
    Web Server: 
    -------------------
            Apache, Nginx, IIS, which serve HTML 
            pages and web content to browsers.
    
    Database Server:
    -------------------
            MySQL, PostgreSQL, Oracle, which
            manage database operations for applications.
    
    File Server:
    -------------------
            Samba, FTP servers, which facilitate
            file storage and sharing across a network.





Advantages:
-----------------
    Centralized Management: 
    -------------------------
        Servers centralize resources and
        services, simplifying management and maintenance.


    Scalability: 
    -------------------
        Servers can handle multiple client requests
        simultaneously and can be scaled to accommodate growing demand.


    Security: 
    -------------------
        Servers offer robust security features, 
        including authentication, encryption, and access controls,
        to protect data and resources.


Disadvantages:
--------------------
    Single Point of Failure: 
    -------------------
            If a server fails, all services
            dependent on it can be disrupted.
   

    Complexity: 
    -------------------
            Setting up and maintaining servers 
            requires specialized knowledge and skills.
   

    Cost: 
    -------------------
            Servers can be expensive to purchase, 
            operate, and maintain, especially at an enterprise level.
    




Features:
------------
        
        Network Interfaces: 
        -------------------
                Servers have network interfaces to handle communication
                with clients over various protocols (HTTP, FTP, SMTP, etc.).
                
                Protocols: 
                ----------
                    Servers support various protocols to communicate with clients.
                    
                    Common protocols include:
                    HTTP/HTTPS: For serving web content securely.
                    FTP/SFTP: For file transfers.
                    SMTP/IMAP/POP3: For email services.
                
            
                IP Addressing: 
                ---------------
                    Servers use IP addresses to identify and communicate over a network.
            
        
        
        Resource Management: 
        -------------------

                Servers manage CPU, memory, storage, and network 
                resources to efficiently handle client requests.
            
                CPU and Memory Management: 
                ------------------------
                    Servers allocate CPU time and 
                    memory to handle client requests efficiently.
            
                Storage Management: 
                ------------------------
                    Servers manage disk storage to store data,
                    including databases, files, and web content.
            
                Load Balancing: 
                ------------------------
                    Servers distribute incoming network traffic
                    across multiple servers to ensure no single 
                    server becomes overwhelmed.
        
        
        
        Security Mechanisms: 
        --------------------------
                Servers implement security measures such as 
                firewalls, SSL/TLS encryption, and access controls
                to protect data and services.
                
                Firewalls:
                ----------------
                        Protect servers from unauthorized access by 
                        filtering incoming and outgoing network traffic.
            
                SSL/TLS Encryption:
                --------------------
                        Encrypts data transmitted between clients and 
                        servers to protect against eavesdropping and tampering.
            
                Access Controls:
                ------------------
                        Implement authentication and authorization to 
                        ensure only authorized users can access server resources.
        
        
        Redundancy and Failover: 
        ------------------------
                Servers often include redundancy and failover 
                mechanisms to ensure high availability and reliability.
        
                Redundant Hardware:
                ------------------
                Servers often have redundant hardware 
                components (e.g., power supplies, network interfaces) to
                ensure continuous operation.
            
            
                Failover Systems: 
                ------------------
                Servers use failover systems to automatically
                switch to a backup server in case of a primary server 
                failure, ensuring high availability.
        



======================================================================
3.5 Code Migration
======================================================================

 
    
    
            Code migration refers to the process of moving
            software code from one environment to another. 
            
            This can involve shifting code between different
            platforms, operating systems, or hardware configurations.
            
            
            It is essential for maintaining compatibility, 
            improving performance, scaling applications, or
            modernizing legacy systems.
            
    
    
        
        Use Case:
        ---------------
            Platform Change: 
            Migrating an application from an on-premises server to a cloud platform.
        
            Performance Improvement: 
            Moving code to a more powerful hardware setup to enhance performance.
        
            System Upgrades: 
            Updating legacy systems to modern platforms to leverage
            new technologies and features.
    
        
    
        Example:
        -----------
            Migrating a web application from a
            Windows server to a Linux server.
        
        
            Moving an application from a local data center
            to a cloud service like AWS, Azure, or Google Cloud.
        
        
            Porting a mobile app from iOS to Android.



    
        Advantages:
        ----------------
            Scalability: 
                Allows applications to leverage the 
                scalable infrastructure of modern 
                platforms, especially cloud services.
        
            Cost Efficiency: 
                Can reduce costs by utilizing more
                efficient or cost-effective environments.
        
            Access to Advanced Features: 
                Enables the use of advanced features and 
                tools available in the new environment.
        
            Improved Performance:
                Can optimize application performance 
                by using better-suited hardware or software environments.
    
        
    
    
        Disadvantages:
        ----------------
            Complexity: 
                Code migration can be complex and 
                requires detailed planning and execution.
        
            Downtime: 
                Migration may involve downtime,
                affecting service availability.
        
            Compatibility Issues:
                Differences in environments can lead to 
                compatibility issues, requiring code modifications.
        
            Data Integrity: 
                Ensuring data integrity during the 
                migration process can be challenging.
    
    
    
    
    
    
            
            Features:
            ------------
            
            Compatibility Checks:
            -------------------------
                Assessing compatibility between the source and target environments.
            
                Environment Comparison: 
                    Evaluate differences between source and
                    target environments, including operating 
                    systems, hardware, software dependencies, and
                    network configurations.
            
                Dependency Analysis: 
                    Identify and analyze dependencies to 
                    ensure all necessary components are compatible
                    with the target environment.
            
            
            
            Automated Tools: 
            -----------------
                Using migration tools to automate parts 
                of the migration process, reducing manual effort.
            
                 Migration Tools: 
                    Software tools like AWS Migration Hub, Azure Migrate,
                    and Google Cloud Migrate can automate parts of the migration
                    process, such as data transfer, configuration adjustments, and
                    environment setup.
            
                Script Automation: 
                    Custom scripts can automate repetitive tasks,
                    such as code adjustments, environment setup, and testing.
            
            
            Testing: 
            ---------------
                Rigorous testing to ensure the application
                functions correctly in the new environment.
            
            
                Pre-Migration Testing:
                    Test the application in the source
                    environment to create a baseline for comparison.
            
                Post-Migration 
                    Testing: Conduct thorough testing in the 
                    target environment to ensure functionality,
                    performance, and stability.
            
                Regression Testing: 
                    Ensure that recent changes or migrations do not 
                    introduce new issues by testing all aspects of the application.
            
            
            
            
            Documentation: 
            -----------------
                    Comprehensive documentation of the migration
                    process to guide future migrations and troubleshooting.
                
                        Migration Plan: 
                            Document the entire migration plan, including 
                            objectives, steps, timelines, resources, and risk management strategies.
                    
                        Configuration Documentation: 
                            Maintain detailed documentation of 
                            both the source and target environment configuration
                            to facilitate troubleshooting and future migrations.
                    
                        Testing Results: 
                            Document testing procedures and results 
                            to validate the success of the migration.









