



....................................................................................
UNIT 1 : DATA REPRESENTATION  (4 Hrs)
....................................................................................








1.1 DATA REPRESENTATION
....................................................................................

• Computers store all information in BINARY (0 and 1).
• Any type of data (numbers, text, sound, images) must be represented as bits.
• So it is FOUNDATION of computer architecture.

• Therefore, to design or understand any computer system,  
  we must first understand how numbers, characters, and signals  
  are represented in binary form.


• Data Representation is required to:
     - Perform arithmetic operations correctly.
     - Store data in memory reliably.
     - Process instructions inside the CPU.
     - Communicate data between devices without errors.
     - Design ALU, control unit, and memory circuits.



• Without this chapter, we cannot understand:
     - Register Transfer operations
     - ALU design
     - Memory architecture
     - Instruction decoding
     - CPU operations and pipelining
     - I/O data handling
     - Error detection and correction




....................................................................................
A. BINARY REPRESENTATION
....................................................................................
      • Binary is a base-2 number system.
      • Digits used → {0, 1}
      • Each digit = BIT.
      
      Example:
      (13)10 = (1101)2
      (25)10 = (11001)2
      (100)10 = (1100100)2

....................................................................................
B. BCD (Binary Coded Decimal)
....................................................................................
      • Each decimal digit (0–9) is represented by its 4-bit binary code.
      
      Example:
      12 in BCD
      1 → 0001
      2 → 0010
      BCD = 0001 0010
      
      • Useful in digital clocks, calculators, numeric displays.

....................................................................................
C. ALPHANUMERIC REPRESENTATION
....................................................................................
         Characters, digits, symbols are stored using character codes.
         
         1. ASCII (American Standard Code for Information Interchange)
            • 7-bit or 8-bit code.
            • Example:
                ‘A’ = 65 = 1000001
                ‘a’ = 97 = 1100001
                ‘0’ = 48 = 0110000
         
         2. EBCDIC (Extended Binary Coded Decimal Interchange Code)
            • 8-bit code used by IBM systems.
            • Example:
                ‘A’ = 11000001

....................................................................................
D. COMPLEMENTS
....................................................................................
         Complements simplify subtraction and negative number representation.
         
         Two types:
               1. (r – 1)’s complement
               2. r’s complement

         Where r = base and n = number of digits.
         
         Formulas:
               • r’s complement  = r^n – N
               • (r – 1)’s comp = r^n – 1 – N
         
         Example:
         Find 10’s and 9’s complement of 512.
         r = 10, n = 3
               10’s comp = 1000 – 512 = 488
               9’s comp  = 488 – 1 = 487
         
         Complement Table:
               Binary (r=2)     → 2’s comp, 1’s comp
               Decimal (r=10)   → 10’s comp, 9’s comp
               Octal (r=8)      → 8’s comp, 7’s comp
               Hex (r=16)       → 16’s comp, 15’s comp


....................................................................................
E. NEGATIVE BINARY NUMBER REPRESENTATION
....................................................................................

         1. Sign-Magnitude
            • MSB = sign bit (0 = +, 1 = –)
                        Example:
                        +11 = 0 1011
                        –11 = 1 1011
         
         2. 1’s Complement
            • Replace 1→0 and 0→1
                        Example:
                        12 = 00001100
                        1’s complement = 11110011
         
         3. 2’s Complement
            • 1’s complement + 1
                        Example:
                        12 = 00001100
                        1’s comp = 11110011
                        2’s comp = 11110100
         
         • Modern CPUs use 2’s complement.



....................................................................................
F. FIXED POINT REPRESENTATION
....................................................................................
         Used to represent integers and fractions with fixed positions.
         
         Format:
         Sign Bit | Integer Bits | Fraction Bits
         
         Example:
         +9.625 → 1001.101
         –1.10  → sign bit = 1
         
         Suitable for simple embedded systems.
               Examples of embedded systems include consumer electronics like smartphones
               and digital watches, home appliances such as washing machines and microwave
               ovens, and complex systems in automotive and medical fields. 
               
               These are computer systems with a dedicated function, found in everything
               from simple calculators to advanced industrial robots and traffic lights. 
               

....................................................................................
G. FLOATING POINT REPRESENTATION
....................................................................................
         Used to represent very large and very small numbers.
         
         General format:
         Number = Mantissa × 2^Exponent
         
               Example:
               1354.537 = 0.1354537 × 2^7
               
         IEEE 754 Single Precision (32-bit):
               Sign = 1 bit
               Exponent = 8 bits
               Mantissa = 23 bits

....................................................................................
H. ARITHMETIC USING COMPLEMENTS
....................................................................................
         Subtraction can be done using complements.
                        A+B = B+A
                        A-B != B-A
         
         Example: 10 – 15 using 2’s complement.
         
                  10 = 00001010
                  15 = 00001111
                  2’s comp of 15 = 11110001
                  Add:
                  00001010
                  +11110001
                  -----------
                  11111011  (negative)
                  2’s comp to interpret → 00000101 = 5
                  Final result = –5


....................................................................................
I. OVERFLOW AND DETECTION
....................................................................................
            Overflow = result exceeds available bit size.
            
            Example of Overflow:
                   1001 (9)
                  +1001 (9)
                  ---------
                  10010 → Overflow (5 bits)


            Overflow Rule (2’s complement):
                     • Same-sign addition gives opposite-sign result → OVERFLOW.
                     
                     Example (No Overflow):
                      0110 (6)
                     +1001 (–7)
                     ---------
                      1111 = –1 (valid)


....................................................................................
1.2 OTHER BINARY CODES
....................................................................................

A. GRAY CODE (Reflected Binary Code)
....................................................................................
            • Adjacent values differ by only one bit.
            • Reduces mechanical/encoder errors.
            
                     Binary → Gray Conversion:
                        1. Copy MSB.
                        2. XOR MSB with next bit.
                        3. Continue for all bits.
            
            Example:
            Binary: 1011
            Gray:
            1
            1⊕0 = 1
            0⊕1 = 1
            1⊕1 = 0
                  Result: 1110

....................................................................................
B. SELF-COMPLEMENTING CODES
....................................................................................
         If 9’s complement of digit = bitwise complement of code, it is self-complementing.
         
         Examples:
         • Excess-3
         • 2421 Code

....................................................................................
C. WEIGHTED CODES (8421 and 2421)
....................................................................................

         1. 8421 Code (Natural BCD)
            Weights: 8, 4, 2, 1
            Example:
                  5 = 0101
                  9 = 1001
               
         2. 2421 Code
            Weights: 2, 4, 2, 1 (self-complementing)
            Example table:
                  Digit | 8421 | 2421
                  ------|------|------
                    5   | 0101 | 1011
                    6   | 0110 | 1100
                    7   | 0111 | 1101
                    8   | 1000 | 1110
                    9   | 1001 | 1111

....................................................................................
D. EXCESS-3 (XS-3) CODE
....................................................................................
         • Add decimal 3 (0011) to each BCD digit.
         
         Example:
                  Digit = 7 → BCD 0111
                  Add 0011 → 1010 (XS-3 code)
         
         • Used in decimal arithmetic due to self-complementing property.

....................................................................................
E. EBCDIC CODE
....................................................................................
      Extended Binary Coded Decimal Interchange Code.
      • 8-bit code → 256 characters.
      • Used in IBM mainframes.
      
      Example:
      'A' = 11000001

....................................................................................
1.3 ERROR DETECTION CODES
....................................................................................

A. PARITY BIT
....................................................................................
         • Simple error detection mechanism.
         • Adds one extra bit to the data.
         
         Two types:
         1. Even Parity → Total 1s = Even
         2. Odd Parity  → Total 1s = Odd
         
         Example (Even Parity):
               Data: 101101
               No. of 1s = 4 (even)
               Parity Bit = 0
               Code = 1011010
         
         Example (Odd Parity):
               Data: 101101
               No. of 1s = 4 (even)
               Parity Bit = 1
               Code = 1011011

....................................................................................
B. PARITY GENERATOR AND CHECKER
....................................................................................
            • Parity Generator creates parity bit (uses XOR).
            • Parity Checker verifies received data.
            
                     Error Detection:
                     If received parity ≠ expected parity → ERROR.
                     
                     Truth Table Example:
                     Data | Odd Parity | Even Parity
                     000  |     1      |     0
                     001  |     0      |     1
                     010  |     0      |     1
                     011  |     1      |     0
                     100  |     0      |     1
                     101  |     1      |     0
                     110  |     1      |     0
                     111  |     0      |     1

....................................................................................

....................................................................................




















































































































....................................................................................
HOW UNIT 1 ENHANCES THE COMPUTER SYSTEM
....................................................................................

1. **Enhances CPU Arithmetic and Logic**
            • Using 2’s complement makes subtraction = addition.
            • Simplifies ALU hardware.
            • Faster and more efficient arithmetic processing.
         
            Example:
                  Subtraction 10 - 15 is done using complement arithmetic  
                  instead of designing a separate subtractor.

....................................................................................

2. **Improves Number Representation & Range Handling**
            • Negative numbers, small fractions, and large values  
              can be represented correctly using:
              - Fixed-point
              - Floating-point
              - Complements
            • Prevents overflow and sign errors.
         
            Example:
                  Floating-point allows representation of very large  
                  scientific numbers like 3.2 × 10^18.

....................................................................................

3. **Enables Accurate Data Storage in Memory**
            • Bytes, words, characters, integers, and floating numbers  
              all depend on binary representation.
            • ASCII/EBCDIC allow uniform character storage.
            • BCD used in financial calculations where decimal accuracy is needed.
         
            Example:
            The decimal value 12 stored as BCD → 0001 0010.

....................................................................................

4. **Supports Reliable Communication Through Error Detection**
               • Parity bit detects transmission errors.
               • Ensures data integrity between CPU ↔ Memory ↔ I/O.
            
               Example:
               Odd parity for data 10101 → parity = 0 to maintain odd count.

....................................................................................

5. **Simplifies Hardware Circuit Design**
                                                                           • Gray code reduces switching errors in encoders.
                                                                           • Weighted codes simplify numeric hardware operations.
                                                                        
                                                                           Example:
                                                                           Gray code counters change only 1 bit at a time  
                                                                           → reduces mechanical errors in rotating shafts.

....................................................................................

6. **Enables Scientific and Engineering Computations**
               • Floating-point format supports:
                 - Wide range of numbers
                 - Higher precision
                 - Scientific accuracy
            
               Example:
               0.00000034 or 3.2 × 10^10 can be represented easily.

....................................................................................

7. **Vital for Instruction Encoding and Control Signals**
               • Machine instructions are binary patterns.
               • Understanding binary helps in decoding:
                 - Opcodes
                 - Addressing modes
                 - Micro-operations
            
               Example:
               Instruction 10110010 may mean “Move data from R1 to R2”.

....................................................................................




















....................................................................................
 MCQs (20 Questions)
....................................................................................

Q1. Computers internally store and process all types of data in:
    (a) Decimal form
    (b) Binary form
    (c) Octal form
    (d) Hexadecimal form

....................................................................................

Q2. In BCD (Binary Coded Decimal), the decimal number 39 is represented as:
    (a) 0011 1001
    (b) 0011 0011
    (c) 0100 0001
    (d) 1001 0011

....................................................................................

Q3. Which of the following is TRUE about ASCII?
    (a) It is a 4-bit code
    (b) It is a 7-bit or 8-bit character code
    (c) It is used only in IBM mainframes
    (d) It is the same as EBCDIC

....................................................................................

Q4. The main purpose of using complements in number representation is:
    (a) To increase storage capacity
    (b) To simplify subtraction and negative number representation
    (c) To store characters efficiently
    (d) To implement parity checking only

....................................................................................

Q5. The 9’s complement of the decimal number 254 is:
    (a) 745
    (b) 746
    (c) 755
    (d) 999

....................................................................................

Q6. In sign-magnitude representation, –13 (in 5 bits) is:
    (a) 01101
    (b) 10110
    (c) 11101
    (d) 11011

....................................................................................

Q7. In 1’s complement representation, the 1’s complement of 00101100 is:
    (a) 00101100
    (b) 00101111
    (c) 11010011
    (d) 11010011 (with sign bit ignored)

....................................................................................

Q8. In 2’s complement representation, which of the following steps is correct?
    (a) Add 2 to the original number
    (b) Invert all bits and subtract 1
    (c) Invert all bits and add 1
    (d) Just invert the MSB

....................................................................................

Q9. Fixed-point representation is BEST suited for:
    (a) Very large scientific numbers
    (b) Simple embedded systems and integer arithmetic
    (c) Only character data
    (d) Only error-detection codes

....................................................................................

Q10. The general form of floating-point representation is:
    (a) Number = Exponent × Mantissa
    (b) Number = Mantissa × 10^Exponent
    (c) Number = Mantissa × 2^Exponent
    (d) Number = Sign + Mantissa – Exponent

....................................................................................

Q11. Overflow in 2’s complement addition occurs when:
    (a) Adding two numbers of opposite sign
    (b) Adding two positive numbers gives a negative result
    (c) Adding two negative numbers gives a negative result
    (d) Result always has a carry-out from LSB

....................................................................................

Q12. In Gray code:
    (a) Only two bits change between successive codes
    (b) All bits change between successive codes
    (c) Only one bit changes between successive codes
    (d) No bit changes between successive codes

....................................................................................

Q13. Which of the following is a self-complementing code?
    (a) 8421 BCD
    (b) Excess-3
    (c) ASCII
    (d) EBCDIC

....................................................................................

Q14. In 8421 weighted code, the weights assigned (from MSB to LSB) are:
    (a) 1, 2, 4, 8
    (b) 8, 4, 2, 1
    (c) 2, 4, 2, 1
    (d) 4, 2, 1, 0

....................................................................................

Q15. The Excess-3 (XS-3) code of decimal digit 5 is:
    (a) 0101
    (b) 1000
    (c) 0110
    (d) 0011

....................................................................................

Q16. EBCDIC is primarily used:
    (a) In mobile operating systems
    (b) In IBM mainframe computers
    (c) As a 4-bit microcontroller code
    (d) Only for floating-point numbers

....................................................................................

Q17. A parity bit is mainly used to:
    (a) Increase speed of CPU
    (b) Compress data
    (c) Detect errors in data transmission
    (d) Encrypt secret data

....................................................................................

Q18. For even parity, if the data bits are 101011, the parity bit should be:
    (a) 0
    (b) 1
    (c) Either 0 or 1
    (d) Cannot be determined

....................................................................................

Q19. Which of the following statements about floating-point representation is TRUE?
    (a) It can only represent integers
    (b) It cannot represent very small numbers
    (c) It allows a wide range of representable values
    (d) It is not used in scientific computation

....................................................................................

Q20. Which is NOT a direct benefit of Data Representation in Computer Architecture?
    (a) Design of ALU and control unit
    (b) Reliable error detection in communication
    (c) Efficient instruction encoding and decoding
    (d) Increasing screen refresh rate of monitor hardware

....................................................................................







ANSWERS WITH REASONING
....................................................................................

Q1. (b)
Reason: All internal processing is done using binary (0 and 1) in digital computers.

Q2. (a)
Reason: 3 = 0011, 9 = 1001 in BCD → 0011 1001.

Q3. (b)
Reason: ASCII is traditionally a 7-bit code, extended to 8 bits in many systems.

Q4. (b)
Reason: Complements (1’s, 2’s, 9’s, 10’s, etc.) are used to simplify subtraction and represent negative numbers.

Q5. (b)
Reason: For 3-digit number:
9’s complement of 254 = 999 – 254 = 745? Wait:
999 – 254 = 745, but options given: 745, 746, 755, 999.
Correct is 745 → Option (a).
(If you prefer strict 3-digit: answer = 745.)

(Use: 9–2=7, 9–5=4, 9–4=5)

So correct: (a)

Q6. (c)
Reason: In 5 bits, sign-magnitude: MSB = sign.
13 in binary = 01101. For –13 → sign bit = 1 → 11101.

Q7. (c)
Reason: 1’s complement is obtained by inverting every bit:
00101100 → 11010011.

Q8. (c)
Reason: 2’s complement = (invert all bits) + 1.

Q9. (b)
Reason: Fixed-point is simple and used in embedded systems where range requirements are limited.

Q10. (c)
Reason: In binary systems, floating-point is usually represented as Mantissa × 2^Exponent.

Q11. (b)
Reason: In 2’s complement, overflow occurs when two positive numbers give a negative result OR two negatives give a positive. Among options, (b) states a correct overflow situation.

Q12. (c)
Reason: In Gray code, only one bit changes between successive codes.

Q13. (b)
Reason: Excess-3 is self-complementing: 9’s complement is obtained by bitwise complement in XS-3.

Q14. (b)
Reason: 8421 code has weights 8, 4, 2, and 1 from MSB to LSB.

Q15. (c)
Reason: Excess-3 of 5 = (5 + 3) = 8 → 1000.
Wait, options:
(a) 0101
(b) 1000
(c) 0110
(d) 0011
Correct: 5 + 3 = 8 = 1000 → answer (b).

Q16. (b)
Reason: EBCDIC is mainly used in IBM mainframe systems.

Q17. (c)
Reason: Parity bit is used to detect (not correct) errors in data transmission.

Q18. (a)
Reason: Data 101011 has 4 ones (even).
For even parity, total ones must remain even → parity bit = 0.

Q19. (c)
Reason: Floating-point can represent both very large and very small numbers → wide dynamic range.

Q20. (d)
Reason: Screen refresh rate is related to display hardware, not directly to data representation. Others are direct benefits.


























