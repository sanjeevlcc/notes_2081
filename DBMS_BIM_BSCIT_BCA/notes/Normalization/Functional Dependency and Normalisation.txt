


                          ******************************************************************
                                       Functional Dependency and Normalisation
                          ******************************************************************






====================================================================================
NOTE/ BOOK


https://industri.fatek.unpatti.ac.id/wp-content/uploads/2019/03/162-Introduction-to-Database-Management-System-Satinder-Bal-Gupta-Aditya-Mittal-Edisi-2-2017.pdf

Page NO: 212
====================================================================================












====================================================================================

UNF
---- BookstoreSales
| SaleID | CustomerName | CustomerAddress | CustomerPhone | BooksPurchased         | AuthorNames                  | PricePerBook  | TotalAmount | SaleDate   | PaymentMethod |
| ------ | ------------ | --------------- | ------------- | ---------------------- | ---------------------------- | ------------- | ----------- | ---------- | ------------- |
| 101    | Ramesh Karki | Kathmandu       | 9812345678    | Book A, Book B         | Author X, Author Y           | 500, 700      | 1200.00     | 2025-08-01 | Cash          |
| 102    | Sita Thapa   | Pokhara         | 9801122334    | Book C, Book D, Book E | Author Z, Author W, Author Q | 400, 550, 300 | 1250.00     | 2025-08-02 | Card          |






1NF
----- BookstoreSales_1NF
| SaleID | CustomerName | CustomerAddress | CustomerPhone | BookTitle | AuthorName | Price | TotalAmount | SaleDate   | PaymentMethod |
| ------ | ------------ | --------------- | ------------- | --------- | ---------- | ----- | ----------- | ---------- | ------------- |
| 101    | Ramesh Karki | Kathmandu       | 9812345678    | Book A    | Author X   | 500   | 1200.00     | 2025-08-01 | Cash          |
| 101    | Ramesh Karki | Kathmandu       | 9812345678    | Book B    | Author Y   | 700   | 1200.00     | 2025-08-01 | Cash          |
| 102    | Sita Thapa   | Pokhara         | 9801122334    | Book C    | Author Z   | 400   | 1250.00     | 2025-08-02 | Card          |
| 102    | Sita Thapa   | Pokhara         | 9801122334    | Book D    | Author W   | 550   | 1250.00     | 2025-08-02 | Card          |
| 102    | Sita Thapa   | Pokhara         | 9801122334    | Book E    | Author Q   | 300   | 1250.00     | 2025-08-02 | Card          |







2NF
-----   Customers         AND          Sales          AND    SaleDetails 

Customers  
| CustomerID | CustomerName | CustomerAddress | CustomerPhone |
| ---------- | ------------ | --------------- | ------------- |
| 1          | Ramesh Karki | Kathmandu       | 9812345678    |
| 2          | Sita Thapa   | Pokhara         | 9801122334    |


Sales 
| SaleID | CustomerID | TotalAmount | SaleDate   | PaymentMethod |
| ------ | ---------- | ----------- | ---------- | ------------- |
| 101    | 1          | 1200.00     | 2025-08-01 | Cash          |
| 102    | 2          | 1250.00     | 2025-08-02 | Card          |


SaleDetails 
| SaleID | BookTitle | AuthorName | Price |
| ------ | --------- | ---------- | ----- |
| 101    | Book A    | Author X   | 500   |
| 101    | Book B    | Author Y   | 700   |
| 102    | Book C    | Author Z   | 400   |
| 102    | Book D    | Author W   | 550   |
| 102    | Book E    | Author Q   | 300   |





3NF
---   Books            and             SaleDetails



Books
| BookID | BookTitle | AuthorName |
| ------ | --------- | ---------- |
| 1      | Book A    | Author X   |
| 2      | Book B    | Author Y   |
| 3      | Book C    | Author Z   |
| 4      | Book D    | Author W   |
| 5      | Book E    | Author Q   |




SaleDetails
| SaleID | BookID | Price |
| ------ | ------ | ----- |
| 101    | 1      | 500   |
| 101    | 2      | 700   |
| 102    | 3      | 400   |
| 102    | 4      | 550   |
| 102    | 5      | 300   |





Customers  
| CustomerID | CustomerName | CustomerAddress | CustomerPhone |
| ---------- | ------------ | --------------- | ------------- |
| 1          | Ramesh Karki | Kathmandu       | 9812345678    |
| 2          | Sita Thapa   | Pokhara         | 9801122334    |


Sales 
| SaleID | CustomerID | TotalAmount | SaleDate   | PaymentMethod |
| ------ | ---------- | ----------- | ---------- | ------------- |
| 101    | 1          | 1200.00     | 2025-08-01 | Cash          |
| 102    | 2          | 1250.00     | 2025-08-02 | Card          |

====================================================================================










====================================================================================



| SaleID | CustomerName | CustomerAddress | CustomerPhone | BooksPurchased | AuthorNames | PricePerBook  | TotalAmount | SaleDate   | PaymentMethod |





| CustomerID | CustomerName | CustomerAddress | CustomerPhone | -------- | SaleID | CustomerID | TotalAmount | SaleDate   | PaymentMethod |         

                        | SaleID | BookID | Price | ------------ | BookID | BookTitle | AuthorName |




CLICK :   https://github.com/sanjeevlcc/notes_2081/blob/main/DBMS_BIM_BSCIT_BCA/notes/Normalization/normilization%20examples.png


====================================================================================












====================================================================================
 Database Normalization
====================================================================================



Definition:
--------------
       Normalization is a database design technique that reduces 
       data redundancy and eliminates undesirable characteristics 
       like Insertion, Update, and Deletion Anomalies.
       
       It works by dividing larger tables into smaller related tables and 
       linking them using relationships (foreign keys).
       
       
       
       
           
           Purpose of Normalization:
           ----------------------------
                   Remove redundant (repetitive) data
                   Store data logically
                   Ensure data integrity
                   Avoid anomalies in Insert, Update, and Delete operations
                   




  Types of Anomalies Prevented
  ----------------------------- rw ...... r select ........ w ins, update, del
  
        Insertion Anomaly – Can’t add data because other required fields are missing
        Update Anomaly – Need to update the same information in multiple places
        Deletion Anomaly – Deleting data accidentally removes other important info
        





Example — Bookstore Sales
--------------------------

Step 0: UNF (Unnormalized Form)
Problem: Repeating groups, multiple values in one column, redundant customer data.



| SaleID | CustomerName | CustomerAddress | CustomerPhone | BooksPurchased         | AuthorNames                  | PricePerBook  | TotalAmount | SaleDate   | PaymentMethod |
| ------ | ------------ | --------------- | ------------- | ---------------------- | ---------------------------- | ------------- | ----------- | ---------- | ------------- |
| 101    | Ramesh Karki | Kathmandu       | 9812345678    | Book A, Book B         | Author X, Author Y           | 500, 700      | 1200.00     | 2025-08-01 | Cash          |
| 102    | Sita Thapa   | Pokhara         | 9801122334    | Book C, Book D, Book E | Author Z, Author W, Author Q | 400, 550, 300 | 1250.00     | 2025-08-02 | Card          |







Step 1: 1NF (First Normal Form)
Rule: Remove repeating groups; each field must have atomic (single) values.



| SaleID | CustomerName | CustomerAddress | CustomerPhone | BookTitle | AuthorName | Price | TotalAmount | SaleDate   | PaymentMethod |
| ------ | ------------ | --------------- | ------------- | --------- | ---------- | ----- | ----------- | ---------- | ------------- |
| 101    | Ramesh Karki | Kathmandu       | 9812345678    | Book A    | Author X   | 500   | 1200.00     | 2025-08-01 | Cash          |
| 101    | Ramesh Karki | Kathmandu       | 9812345678    | Book B    | Author Y   | 700   | 1200.00     | 2025-08-01 | Cash          |
| 102    | Sita Thapa   | Pokhara         | 9801122334    | Book C    | Author Z   | 400   | 1250.00     | 2025-08-02 | Card          |
| 102    | Sita Thapa   | Pokhara         | 9801122334    | Book D    | Author W   | 550   | 1250.00     | 2025-08-02 | Card          |
| 102    | Sita Thapa   | Pokhara         | 9801122334    | Book E    | Author Q   | 300   | 1250.00     | 2025-08-02 | Card          |




Remaining issues: Customer info repeated; TotalAmount repeated for each book.







Step 2: 2NF (Second Normal Form)
Rule: Remove partial dependencies; move customer info to a separate table.



Customers Table
| CustomerID | CustomerName | CustomerAddress | CustomerPhone |
| ---------- | ------------ | --------------- | ------------- |
| 1          | Ramesh Karki | Kathmandu       | 9812345678    |
| 2          | Sita Thapa   | Pokhara         | 9801122334    |



Sales Table
| SaleID | CustomerID | TotalAmount | SaleDate   | PaymentMethod |
| ------ | ---------- | ----------- | ---------- | ------------- |
| 101    | 1          | 1200.00     | 2025-08-01 | Cash          |
| 102    | 2          | 1250.00     | 2025-08-02 | Card          |


SaleDetails Table
| SaleID | BookTitle | AuthorName | Price |
| ------ | --------- | ---------- | ----- |
| 101    | Book A    | Author X   | 500   |
| 101    | Book B    | Author Y   | 700   |
| 102    | Book C    | Author Z   | 400   |
| 102    | Book D    | Author W   | 550   |
| 102    | Book E    | Author Q   | 300   |







Step 3: 3NF (Third Normal Form)
Rule: Remove transitive dependencies; author info depends on book, not sale.



Books Table
| BookID | BookTitle | AuthorName |
| ------ | --------- | ---------- |
| 1      | Book A    | Author X   |
| 2      | Book B    | Author Y   |
| 3      | Book C    | Author Z   |
| 4      | Book D    | Author W   |
| 5      | Book E    | Author Q   |



SaleDetails_3NF Table
| SaleID | BookID | Price |
| ------ | ------ | ----- |
| 101    | 1      | 500   |
| 101    | 2      | 700   |
| 102    | 3      | 400   |
| 102    | 4      | 550   |
| 102    | 5      | 300   |




CLICK :   https://github.com/sanjeevlcc/notes_2081/blob/main/DBMS_BIM_BSCIT_BCA/notes/Normalization/normilization%20examples.png


====================================================================================













====================================================================================
Anomaly in databases 
====================================================================================

        An anomaly in databases is an undesirable or inconsistent situation that happens when 
        data is stored in a poorly structured table (usually unnormalized).
        
        It causes problems when inserting, updating, or deleting data, leading to:
        
                  Data redundancy (same information stored in multiple places)
                  Inconsistencies (different values for the same fact)
                  Loss of important information (when deleting)





1. Insertion Anomaly
--------------------------
Problem: In UNF/1NF, you cannot insert certain data without adding unrelated data.

           Example:
           Suppose a new customer wants to register before making a purchase.
               In BookstoreSales_1NF, every row requires SaleID, BookTitle, AuthorName, Price etc.
               You cannot store just the customer info unless you also create a fake sale entry.
           
           | SaleID   | CustomerName | BookTitle | AuthorName | Price   | … |
           | -------- | ------------ | --------- | ---------- | ------- | - |
           | **NULL** | Ram Bahadur  | **???**   | **???**    | **???** | … |
           


Why it’s bad:
You’re forced to insert a fake book or sale just to add a customer record.








2. Update Anomaly
--------------------------
Problem: Updating a single piece of information requires multiple changes,
          and missing one causes inconsistencies.

Example:
  Ramesh Karki changes his phone number from 9812345678 to 9811111111.
      In BookstoreSales_1NF, his phone appears in every row of every sale he made.

              Before Update
              | SaleID | CustomerName | CustomerPhone | BookTitle |
              | ------ | ------------ | ------------- | --------- |
              | 101    | Ramesh Karki | 9812345678    | Book A    |
              | 101    | Ramesh Karki | 9812345678    | Book B    |
              
              
              If you forget to update even one row, you’ll have inconsistent data:
              | SaleID | CustomerName | CustomerPhone | BookTitle |                        |
              | ------ | ------------ | ------------- | --------- | ---------------------- |
              | 101    | Ramesh Karki | 9811111111    | Book A    |                        |
              | 101    | Ramesh Karki | 9812345678    | Book B    | ❌ (Old number remains) |

Why it’s bad:
Leads to data inconsistency and unreliable records.











3. Deletion Anomaly
--------------------------
Problem: Deleting one fact accidentally removes other valuable information.

Example:
If we delete the sale record for Book A from BookstoreSales_1NF,
and that’s the only purchase by Ramesh Karki, then all his customer details are lost.

              Before deletion:
              | SaleID | CustomerName | CustomerPhone | BookTitle |
              | ------ | ------------ | ------------- | --------- |
              | 101    | Ramesh Karki | 9812345678    | Book A    |
              
              
              
              
              After deletion → Ramesh Karki’s customer profile disappears entirely.
              


Why it’s bad:
We lose customer information just because we deleted a related sale.







How Normalization Fixes This
-----------------------------
          Insertion Anomaly → Fixed by having a Customers table (can insert customer without sale).
          
          Update Anomaly → Fixed by storing customer info in one place only.
          
          Deletion Anomaly → Fixed by separating customers and sales so deleting a sale doesn’t delete the customer.
          


====================================================================================















====================================================================================
Database Normal Forms
====================================================================================
      The inventor of the relational model Edgar Codd proposed the 
      theory of normalization of data with the introduction of the First Normal Form, 
      and he continued to extend theory with Second and Third Normal Form. 
      
      Later he joined Raymond F. Boyce to develop the theory of Boyce-Codd Normal Form.




Database Normal Forms
----------------------------
                1NF (First Normal Form)
                2NF (Second Normal Form)
                3NF (Third Normal Form)
                BCNF (Boyce-Codd Normal Form)
                4NF (Fourth Normal Form)
                5NF (Fifth Normal Form)
                6NF (Sixth Normal Form)



The Theory of Data Normalization in MySQL server is still
being developed further. For example, there are discussions 
even on 6th Normal Form. 

However, in most practical applications, normalization
achieves its best in 3rd Normal Form. 




Normal Form	Description
---------------------------
          1NF	
               A relation is in 1NF if it contains an atomic value (no multivalues).
          
          
          
          2NF	
               A relation will be in 2NF if it is in 1NF and 
               all non-key attributes are fully functional dependent
               on the primary key.
          
          
          3NF	
               A relation will be in 3NF if it is in 2NF and 
               no transition dependency exists.
          
          
          
          BCNF	
                A stronger definition of 3NF is known as Boyce
                Codd's normal form.
          
          
          
          4NF	
                A relation will be in 4NF if it is in Boyce
                Codd's normal form and has no multi-valued
                dependency.
          
          
          
          
          5NF	
                A relation is in 5NF. If it is in 4NF and does
                not contain any join dependency, joining should 
                be lossless.









====================================================================================
Advantages  and Disadvantages of Normalization
====================================================================================

           
           Advantages of Normalization
           ------------------------------
                     Normalization helps to minimize data redundancy.
                     Greater overall database organization.
                     Data consistency within the database.
                     Much more flexible database design.
                     Enforces the concept of relational integrity.
           
           
           
           
           Disadvantages of Normalization
           ------------------------------
                      You cannot start building the database before knowing what the user needs.
                      The performance degrades when normalizing the relations to higher normal forms, 
                      i.e., 4NF, 5NF.
                      It is very time-consuming and difficult to normalize relations of a higher degree.
                      Careless decomposition may lead to a bad database design, leading to serious problems.









====================================================================================
Database Keys
====================================================================================
             Super Key             
             Candidate Key
             Primary Key          
             Alternate Key
             Foreign Key
             Composite Key

table t1 {emp_id, name, citizenship_id, email_id, department_id}




mysql> select * from t1;
+--------+----------------+----------------+--------------------+---------------+
| emp_id | name           | citizenship_id | email_id           | department_id |
+--------+----------------+----------------+--------------------+---------------+




Super Key:
-----------------
         Any combination of possible attributes that uniquely identifies a tuple.
         It is a sublet of cndidate key
         
         Examples: 
         {emp_id} 
         {citizenship_id}
         {email_id}
         
         {emp_id, citizenship_id}
         {email_id, citizenship_id}
         {email_id, emp_id}
         
         {name, email_id}
         {emp_id,name, email_id}
         {emp_id, citizenship_id}, etc.





-- Create the table t1
CREATE TABLE t1 (
    emp_id INT PRIMARY KEY,
    name VARCHAR(100),
    citizenship_id VARCHAR(20),
    email_id VARCHAR(50),
    department_id INT
);



-- Insert data with English script
INSERT INTO t1 VALUES
(6, 'Suman Shrestha', 'NEP-123', 'suman@example.com', 105),
(7, 'Sarita Rai', 'NEP-456', 'sarita@example.com', 106),
(8, 'Raj Gurung', 'NEP-789', 'raj@example.com', 107),
(9, 'Bibek Paudel', 'NEP-012', 'bibek@example.com', 105),
(10, 'Anita Rana', 'NEP-345', 'anita@example.com', 108);




mysql> select * from t1;
+--------+----------------+----------------+--------------------+---------------+
| emp_id | name           | citizenship_id | email_id           | department_id |
+--------+----------------+----------------+--------------------+---------------+
|      6 | Suman Shrestha | NEP-123        | suman@example.com  |           105 |
|      7 | Sarita Rai     | NEP-456        | sarita@example.com |           106 |
|      8 | Raj Gurung     | NEP-789        | raj@example.com    |           107 |
|      9 | Bibek Paudel   | NEP-012        | bibek@example.com  |           105 |
|     10 | Anita Rana     | NEP-345        | anita@example.com  |           108 |
+--------+----------------+----------------+--------------------+---------------+






Candidate Key:
-----------------
         A minimal super key, meaning no subset of the key can uniquely identify a tuple.
         No NULL VALUES
         A attribute where PRIMARY key can be selected
         
         Examples: 
         {emp_id}, 
         {email_id}, 
         {emp_id, citizenship_id, email_id)
         {emp_id, citizenship_id}}
         { citizenship_id, email_id}etc.






Primary Key:
-----------------
         A candidate key chosen to be the main identifier for the table.
         It must be unique for each tuple and cannot contain NULL values.
         it serves as the main identifier for the table.
         
         Examples:
         {emp_id}, 
         
         {email_id}





Alternate Key:
-----------------
         Candidate keys that are not chosen as the primary key.
         Examples: 
                   If {emp_id} is chosen as the primary key, 
                   then {email_id} is an alternate key.


         {emp_id, name, citizenship_id, email_id, department_id}
         ---PK--------------AK------------AK-------------------




Foreign Key:
-----------------
         An attribute that refers to the primary key in another table.
         It enforces referential integrity between the two related tables.
         It establishes a link between two tables by referencing the 
            primary key in another table.


         Examples: 
         If there is another table with a primary key, 
         say {dept_id}, and department_id in t1 refers to {dept_id}, 
         then it is a foreign key.




Composite Key:
-----------------
         A key that consists of more than one attribute.
         
         Examples: 
         {emp_id, email_id}, {name, citizenship_id, department_id}





                        -- Super Key
                        SELECT 
                            emp_id, name, citizenship_id, email_id, department_id
                        FROM 
                            t1;



            -- Candidate Key
            SELECT 
                emp_id, email_id
            FROM 
                t1;



                            -- Primary Key
                            SELECT 
                                emp_id
                            FROM 
                                t1;

                                                 -- Alternate Key
                                                 SELECT 
                                                     email_id
                                                 FROM 
                                                     t1;






            -- Foreign Key (Assuming there is 
            another table 'departments' with a 
            primary key 'dept_id')


                      -- Create the 'departments' table
                      CREATE TABLE departments (
                          dept_id INT PRIMARY KEY,
                          department_name VARCHAR(50)
                      );

                           -- Insert data into the 'departments' table
                           INSERT INTO departments VALUES
                           (101, 'HR'),
                           (102, 'IT'),
                           (103, 'Finance'),
                           (104, 'Marketing'),
                           (105, 'Operations'),
                           (106, 'Research'),
                           (107, 'Sales'),
                           (108, 'Customer Service');

            SELECT 
                emp_id, name, citizenship_id, email_id, t1.department_id, d.dept_id
            FROM 
                t1
            JOIN 
                departments d ON t1.department_id = d.dept_id;


+--------+----------------+----------------+--------------------+---------------+---------+
| emp_id | name           | citizenship_id | email_id           | department_id | dept_id |
+--------+----------------+----------------+--------------------+---------------+---------+
|      6 | Suman Shrestha | NEP-123        | suman@example.com  |           105 |     105 |
|      7 | Sarita Rai     | NEP-456        | sarita@example.com |           106 |     106 |
|      8 | Raj Gurung     | NEP-789        | raj@example.com    |           107 |     107 |
|      9 | Bibek Paudel   | NEP-012        | bibek@example.com  |           105 |     105 |
|     10 | Anita Rana     | NEP-345        | anita@example.com  |           108 |     108 |
+--------+----------------+----------------+--------------------+---------------+---------+



                              -- Composite Key
                              SELECT 
                                  emp_id, email_id
                              FROM 
                                  t1;












====================================================================================
Functional Dependencies
====================================================================================

Functional dependencies are the result of interrelationships 
between attributes or in between tuples in any relation.

Definition : 
--------------
In relation R,
          X and Y are two subsets of attributes.
          Y is said to be functionally dependent on X (written as X → Y)
                     if, for a given value of X, there is exactly one unique value of Y.


It is denoted by X → Y (Y depends upon X).
           emp_id  → name  


Determinant :
      Here X is known as determinant of functional dependency.

                         X      →   Y
                    determinant   dependent

                         emp_id  → name  






Explanation
     Functional dependencies express how one attribute (or set of attributes) determines another.
     They are not about formulas, but about uniqueness of mapping.
     Functional dependencies are key for normalization — they help decide how to split tables.




EXAMPLE SCNERIO
--------------------
          emp_id  → name             // VALID
          6  → Suman Shrestha 
          7  → Sarita Rai


          emp_id  → name             // VALID
          6  → Suman Shresth
          6  → Suman Shresth


          emp_id  → name             // VALID
          6  → Suman Shrestha 
          7  → Suman Shrestha 


          emp_id  → name             // INVALID
          6  → Suman Shrestha 
          6  → Sarita Rai

+--------+----------------+----------------+--------------------+---------------+
| emp_id | name           | citizenship_id | email_id           | department_id |
+--------+----------------+----------------+--------------------+---------------+
|      6 | Suman Shrestha | NEP-123        | suman@example.com  |           105 |
|      7 | Sarita Rai     | NEP-456        | sarita@example.com |           106 |
|      8 | Raj Gurung     | NEP-789        | raj@example.com    |           107 |
|      9 | Bibek Paudel   | NEP-012        | bibek@example.com  |           105 |
|     10 | Anita Rana     | NEP-345        | anita@example.com  |           108 |
+--------+----------------+----------------+--------------------+---------------+









Example — Bookstore Sales
---------------------------

          
          Relation:
                 Sales(SaleID, CustomerID, CustomerName, CustomerPhone, BookID, BookTitle, Price)
          
          
          
          
          Functional Dependencies:
                    SaleID → CustomerID, SaleDate, PaymentMethod
                    (Each sale has one customer and payment details.)
                    
                    CustomerID → CustomerName, CustomerPhone
                    (A customer’s ID determines their name and phone.)
                    
                    BookID → BookTitle, Price
                    (Each book ID corresponds to one title and price.)
                    
          
          
          
          Diagram of Functional Dependencies
          -------------------------------------
                        CustomerID ───────→ CustomerName
                             │             → CustomerPhone
                             │
                             └── SaleID ───→ SaleDate
                                            → PaymentMethod
                        
                        BookID ───────────→ BookTitle
                                            → Price
                        
          
          
          
          Visual Flow:
          ---------------
                   CustomerID  →  CustomerName, CustomerPhone
                   SaleID      →  SaleDate, PaymentMethod
                   BookID      →  BookTitle, Price
          
          
          
          
          
          
          
          
          
          
          Diagram (Graph Style)
          ----------------------
          +------------+           +-------------------+
          | CustomerID | ------→   | CustomerName      |
          |            | ------→   | CustomerPhone     |
          +------------+           +-------------------+
          
          +--------+               +-------------------+
          | SaleID | ------→       | SaleDate           |
          |        | ------→       | PaymentMethod      |
          +--------+               +-------------------+
          
          +--------+               +-------------------+
          | BookID | ------→       | BookTitle          |
          |        | ------→       | Price              |
          +--------+               +-------------------+
          
          
          
          








====================================================================================
Functional Dependency Chart/Diagram
====================================================================================

It is the graphical representation of function dependencies
among attributes in any relation. 

The following four steps are followed to draw FD chart.


          1. Find out the primary key attributes.
          2. Make a rectangle and write all primary key attributes inside it.
          3. Write all non-prime key attributes outside the rectangle.
          4. Use arrows to show functional dependency among attributes


Example. 
----------
  Consider the following relation:
         Professor (Pfcode, Dept, Head, Time) It is assumed that
         (i) A professor can work in more than one dept.
         (ii) The time he spends in each dept is given.
         (iii) Each dept has only one head.

   Draw the dependency diagram for the given 
   relation by identifying the dependencies.

                                     Pfcode → Dept
                                     Dept  → Head
                                     Pfcode, Dept → Time
    

                                              OR

                    R1 or T1 (Pfcode → Dept , Dept  → Head, Pfcode Dept → Time)


                    Pfcode → Dept , Dept  → Head, Pfcode Dept → Time
                    ---A-------B------B-------C------AB-----------D---

                    R1: FD  (A → B, B → C, AB → D)











====================================================================================
Prime and Non-Prime Attributes
====================================================================================
      For a given relation R= {A1,A2,A3,………..,An}, 
      
      An attribute A is a prime attribute if A is a part of any candidate key of R 
      otherwise A is a non-prime attribute

                     EXAMPLE
                     -------
                     R(A, B, C, D, E, F, G, H) 

                     FD = {D→AB, B→A, C→A, F→G, H→FGD, E→A}
                     
                     Solution
                     RHS: AB A A G FGD A =>> C E H is missing 
                     
                     CK = CEH 
                     
                     Prime Attributes = CEH
                     Non-Prime Attributes = ABDFG
                     
                     
                               CEH      ABDFG
                             --PA--------NPA----




Example
-----------

    Functional dependencies:
    
           {emp_id} -> {name, citizenship_id, email_id, department_id}
           {email_id} -> {name}
           {department_id} -> {citizenship_id, email_id}           

               +--------+----------------+----------------+--------------------+---------------+
               | emp_id | name           | citizenship_id | email_id           | department_id |
               +--------+----------------+----------------+--------------------+---------------+
                  A          B                 C                D                     E


                  {emp_id} -> {name, citizenship_id, email_id, department_id}
                       A -> BCDE
                  {email_id} -> {name}
                       D-> B
                  {department_id} -> {citizenship_id, email_id}
                       E->CD



                       FD:
                        A -> BCDE
                        D-> B
                        E->CD
                 
                          RHS : A
                          A+ -> A -> A BCDE  = ABCD              = R
                 
                             CK = A
                             PA = A
                             NPA = BCDE
                    
                 
                 Prime Attributes: PA = A                  
                                      emp_id
                 
                 Non-Prime Attributes: NPA = BCDE          
                                  name, citizenship_id, email_id, department_id



               +--------+----------------+----------------+--------------------+---------------+
               | emp_id | name           | citizenship_id | email_id           | department_id |
               +--------+----------------+----------------+--------------------+---------------+
                  A          B                 C                D                     E
        ----------PA---------NPA--------------NPA----------------NPA--------------------NPA--------









              
              EXAMPLE
              --------------
              
              
              | **BookID** | **Title**                    | **Author**           | **Price** | **PublisherID** | **PublisherName**     |
              | ---------- | ---------------------------- | -------------------- | --------- | --------------- | --------------------- |
              
              Candidate Key : BookID (uniquely identifies each record)
              
              Prime Attributes: Attributes that are part of at least one Candidate Key are called Prime Attributes.
                                BookID is the only Candidate Key → Prime Attribute = BookID
              
              Non-Prime Attributes: Attributes that are not part of any Candidate Key are called Non-Prime Attributes.
                                    Title, Author, Price, PublisherID, PublisherName are not part of the Candidate Key.
              
              
              






           Example
           -----------
           Consider a relation R(A, B, C, D, E, F, G, H) 
           having a set of FD’s F = {D→AB, B→A, C→A, F→G, H→FGD, E→A}. 
           
           What are the candidate keys of relation R? 
           Also find prime and non-prime attributes.


                Sol. 
                Consider a subset K={C, E, H} of R. 

                CEH is a candidate key as all attributes does not 
                appear on right hand side of any FD in F. 
                
                It can also be proved as follows.
                Compute K+ which gives ABCDEFH. 
                Now compute closure of every subset of K such as CE, EH and CH. 
                
                First consider Y= {C,E}, the closure Y+
                CE = CE = CAE or = AC ≠ R.
                
                Second consider Y={E,H}, the closure Y+
                 = ABDEFGH ≠ R.

               Finally, consider Y= { C,H}, the closure Y+
                = ABCDFGH ≠ R.
               
               Thus, CEH is a candidate key.
               
               Prime Attributes are = CEH
               Non-Prime Attributes are = ABDFG












====================================================================================
Types of Functional Dependencie
====================================================================================
There are four major types of FD’s.
                Trival Dependency and Non-trival Dependency
                Single Valued Dependency and Multivalued Dependency
                Partial Dependency and Fully Functional Dependency 
                Transitive Dependency and Non-transitive Dependency 





Consider TABLE
---------------------------------------------------------------------------------------------------------------
| Book_ID | Title             | Author           | Publisher     | Price | Genre       | Publisher\_Location  |
| -------- | ----------------- | ---------------- | ------------- | ----- | ----------- | ------------------- |
| B001     | DBMS Concepts     | Navathe          | Pearson       | 500   | Education   | USA                 |
| B002     | Operating Systems | Silberschatz     | Wiley         | 600   | Education   | USA                 |
| B003     | Networking Basics | Tanenbaum        | Pearson       | 450   | Education   | USA                 |
| B004     | The Alchemist     | Paulo Coelho     | HarperCollins | 350   | Fiction     | UK                  |
| B005     | Clean Code        | Robert C. Martin | Pearson       | 700   | Programming | USA                 |
---------------------------------------------------------------------------------------------------------------





Trival Dependency and Non-trival Dependency
---------------------------------------------------

    Trival FD : 
    ----------------
    In any relation R, X → Y is trival if Y ⊆ X (Y is the subset of X).
    
            EXAMPLE
              A dependency is trivial if the dependent attribute is already part of the determinant.
              
              Example:
              {Book_ID, Title} → Title ✅ (Trivial because Title is part of the left-hand side) 
                      
       
    
    
    Non-trival FD : 
    ----------------
    In any relation R, X → Y is non-trival if Y ⊆ X (Y is not the subset of X)
    
              EXAMPLE
                Dependency is non-trivial if the dependent attribute is not part of the determinant.
                
                Example:
                {Book_ID} → Title ✅ (Non-trivial because Title is not part of Book_ID) 











Single-Valued and Multivalued Dependency
---------------------------------------------------
Single-Valued Dependency:
---------------------------
    Each value of determinant determines a single value of the dependent attribute.
        Example:
        {Book_ID} → Price ✅ (One book has only one price)



Multivalued Dependency:
---------------------------
  Each determinant value determines multiple independent values for another attribute.
    Example:
    {Author} →→ Title ✅ (An author can write multiple titles)











Partial Dependency and Fully Functional Dependency 
---------------------------------------------------



Fully functional dependency : 
------------------------------
Let A be the non-prime key attribute and value of A 
      is dependent upon all prime key attributes. 
      Then A is said to be fully functional dependent. 

      A fully functional dependency occurs when a 
      non-prime attribute is functionally dependent on the entire
      candidate key, not just a part of it.

      In this case, the non-prime attribute depends on the entire 
      set of attributes that form the candidate key.

   For example, if we have a functional dependency 
         
             {emp_id} -> {name},
   
       where name depends on 
       the entire candidate key (emp_id), 
       it would be a fully functional dependency.




        
        Fully Functional Dependency:
        
        (Assume Primary Key = {Book_ID})
        
        When removing any attribute from the determinant means the dependency no longer holds.
        Example:
        {Book_ID} → Title ✅ (Full dependency — Book_ID alone determines Title)





  
Partial dependency : 
----------------------
Suppose you have more than one attributes in primary key. 
   
      Let A be the non-prime key attribute. 
          If A is not dependent upon all prime key attributes 
          then partial dependency exists.
   
          A partial dependency occurs when a 
          non-prime attribute is functionally dependent 
          on only part of a candidate key, not the entire key.
   
   
   
          In other words, a non-prime attribute depends on only 
          a portion (proper subset) of the candidate key.
   
   
    
    Partial Dependency:
    If only part of a composite key determines the dependent attribute.
    Example:
    (Assume composite key {Author, Publisher} is used)
    {Author} → Publisher_Location ✅ (Publisher location depends only on Publisher, not the full key)







Transitive Dependency and Non-transitive Dependency 
---------------------------------------------------


Transitive dependency : 
----------------------------
    Transitive dependency is due to dependency 
    between non-prime key attributes. 
    
    Suppose in a relation R, X → Y (Y depen upon X), and
                             Y → Z (Z depends upon Y), 
    
                        then X → Z (Z depends upon X).



                 Therefore, Z is said to be 
                 transitively  dependent upon X.

                i.e X → Y   Y → Z   --------- X → Z



        A transitive dependency occurs when a 
        non-prime attribute is functionally
        dependent on another non-prime attribute,
        rather than directly on the candidate key.

        In other words, the dependency involves a 
        chain of functional dependencies where 
        a non-prime attribute depends on another 
        non-prime attribute that, in turn, 
        depends on the candidate key.

        Transitive dependencies can lead to data
        redundancy and are typically 
        eliminated in database normalization.
        


        Example in the context of the t1 table: 
         {emp_id} -> {department_id} -> {citizenship_id} 

          is a transitive dependency if
          citizenship_id depends on department_id and, in turn,
          department_id depends on emp_id.








Non-transitive dependency : 
----------------------------
       Any functional dependency which is not transitive 
       is known as Non-transitive dependency.
       
       Non-transitive dependency exists if there is 
       no dependency between non-prime key attributes.



          A non-transitive dependency occurs when a
          non-prime attribute is directly functionally
          dependent on the candidate key without involving
          any intermediate non-prime attributes.


        
        In this case, the dependency is straightforward 
        and does not involve a chain of dependencies.
        
        Non-transitive dependencies are usually desirable
        in a normalized relational database.
        



             
             Example in the context of the t1 table: 
             
             {emp_id} -> {name, citizenship_id, email_id, department_id} 
             is a non-transitive dependency
             
             because name, citizenship_id, email_id, and department_id
             directly depend on the candidate key emp_id.
             






Single Valued Dependency and Multivalued Dependency
---------------------------------------------------
Single valued dependency : 
-----------------------------
        In any relation R, if for a particular value 
        of X, Y has single value then it is known as 
        single valued dependency.



        A single-valued dependency occurs when the value 
        of one attribute uniquely determines the value of 
        another attribute, and this relationship holds
        for all possible values in the database.



          In other words, if attribute A determines
          attribute B (A -> B), and each value of
          A uniquely determines one and only one
          value of B, then it's a single-valued dependency.



            
            Example in the context of the t1 table: 
            {emp_id} -> {name}, meaning that each employee ID 
                                uniquely determines the employee's name.





Multivalued dependency (MVD) : 
-----------------------------


             In any relation R, if for a particular value
             of X, Y has more then one value, 
             then it is known as multivalued dependency. 
             
             It is denoted by 
             X →→ Y
             
             
             
             A multivalued dependency occurs when the
             presence of certain values in 
             one attribute uniquely determines the
             values in ano ther attribute, and this relationship 
             holds for all possible values inthe database.
             
             
             
             MVD is often expressed as X ->> Y, where X and Y
             are sets of attributes, and X uniquely 
             determines a set of values in Y.
             
             
             
             Example in the context of the t1 table: 
                 {emp_id} ->> {citizenship_id}, meaning that for each employee ID, there
                 can be multiple citizenship IDs.
             
             
             










====================================================================================
Dependencies and Logical Implications
or 
Properties of FD
====================================================================================


              Given a relational schema R and a set of functional dependencies F. 
              
              
              
              A functional dependency X → Y (Not in F) on R is said to be
              logically implied by the set of functional dependencies 
              
              
              
              
              F on R if for relation R on the relational schema that 
              satisfies F also satisfies X → Y.
              
              
              
              
              Example. Consider the relation schema R= (A, B, C, D) and 
                            the set of FD’s F = {A→B, B→C, C→D}. 
              
                       Then the FD’s A → C, B → D and A → D are logically implied
              
              





Armstrong’s Axioms - RAT rule
----------------------------------imp



| BookID | Title                     | Author          | Publisher   | Price | Category     |
| ------ | ------------------------- | --------------- | ----------- | ----- | ------------ |
| B1     | Database Concepts         | Elmasri         | Pearson     | 500   | DBMS         |
| B2     | Learning SQL              | Alan Beaulieu   | O’Reilly    | 450   | DBMS         |
| B3     | Java Programming          | Herbert Schildt | McGraw-Hill | 600   | Programming  |
| B4     | Python Crash Course       | Eric Matthes    | No Starch   | 550   | Programming  |
| B5     | Data Science for Business | Foster Provost  | O’Reilly    | 700   | Data Science |



Let’s assume the following FDs for our table:
            BookID → Title, Author, Publisher, Price, Category
            Title → Author, Publisher, Price, Category
            Publisher → Category





     The following three rules called inference axioms or Armstrong’s Axioms 
     can be used to find  all the FDs logically implied by a set of FDs.


     Let X, Y, Z, and W be subsets of attributes  of a relation R. 



     The following axioms hold:

      1. Reflexivity. 
      -------------------
      If Y is a subset of X, then X → Y. 
      
      This also implies that X → X always holds. 
                Employee_Id → Employee_Id
      
      Functional dependencies of this type 
      are called trivial functional dependencies.




Example:
From BookID → Title, Author, Publisher, Price, Category
Reflexivity says: Since {Title} is a subset of {BookID, Title}, we have BookID, Title → Title (trivial dependency).









      2. Augmentation. 
      -------------------
      If X → Y holds and Z is a set of attributes, 
      then ZX → ZY.


Example:
      Given Title → Author
      Augment with Publisher → Title, Publisher → Author, Publisher





      3. Transitivity. 
      -------------------
      If X → Y holds 
      and Y → Z holds, 
      then X → Z holds.


             EXAMPLE
             Employee_Id   → Employee_Name
             Employee_Name → Address
             Employee_Id   → Address 

Example:
      BookID → Title and Title → Author
      Therefore, BookID → Author (by transitivity).






      These rules are Sound and Complete. 
      They are sound because they do not generate 
      any invalid functional dependencies. 
      
      
      They are complete because they allow us 
      to generate F+ (closure of F) from the given 
      set of functional dependencies F. 




      4. Additivity or Union. 
      -------------------------
      If X → Y and 
         X → Z, 
      then X → YZ holds.




        5. Projectivity or Decomposition. 
        ----------------------------------
        If   X → YZ holds, 
        then  and X → Z also X → Y
        
                  NOTE:    XY → Z  
                       then X → Z and Y → Z DONT HOLD







         6. Pseudotransitivity. 
         -------------------------
         If XZ → W holds, 
         then XZ → W holds.





                       --------------------------SUMMARY--------------------------------
                       X → Y                 Y is a subset of X         Reflexivity.                 
                       ZX → ZY               X → Y holds and Z          Augmentation
                       X → Z                 X → Y,Y → Z                Transitivity
                       X → YZ                X → Y, X → Z               Union
                       X → Y,X → Z           X → YZ                     Decomposition
                       X → Z and Y → Z       XY → Z                     DONT HOLD
                       XZ → W                XZ → W                     Pseudotransitivity
                       --------------------------------------------------------------------




      Example. 
      
      Let R = (A, B, C, D) and 
      F be the set of functional dependencies for 
      R given by {A→B, A→C, BC→D}. 
      
      Prove A→D.


               Sol. Given set of functional dependencies for 
               a relation R is {A→B, A→C, BC→D} 
               
               By using Armstrong Axioms, named projectivity, we can show that
                     A→BC (as A→B, A→C)
               
                 Since BC→D, so by transitivity rule,
                
               A→BC and BC→D means A→D. Hence proved.





     Example. 
     
     Consider a relation R2(A, B, C, D, E, F) and 
     a set of functional dependencies FD={AB→C, C→FA, F→E} that hold on R2. 
     
     (i) Using Armstrong’s axioms show that the functional dependency AB→E also holds 
     on R. 
     (ii) Does AB→F hold for FD1 = {AB→CD, C→E, DE→F}?

               Sol.
               (i) AB→C (given). 
                Apply decomposition to C→FA, get C→F. 
                F→E (given). 
                Apply transitivity to AB→C, C→F, F→E, get AB→E. Hence proved.
               
               
               (ii) Yes. We can prove it as follows:
                AB→CD (given). 
                C→E (given). Apply augmentation to C→E, get, CD→DE. 
                DE→F (given). 
                Apply transitivity to AB→CD, CD→DE and DE→F, get AB→









      Example. 
      
      Let F = {AB → C, B → D, CD→E, CE→GH}. 
      Give a derivation sequence on FD, {AB→G} using only Armstrong’s axioms. 


                  Sol. 
                  
                  We have to derive AB → G
                  
                  AB → ABE (augmentation: AB → E with AB) 
                  ABE → CE (augmentation: AB → C with E) 
                  AB → CE (transitivity: AB → ABE and ABE → CE) 
                  AB → GH (transitivity: AB → CE and CE → GH) 
                  GH → G (reflexivity) 
                  AB → G (transitivity: AB → GH and GH → G)







====================================================================================
Closure of an Attribute
====================================================================================

          Closure of an Attribute can be defined as a set of
          attributes that can be functionally determined from it.
          
                                              OR
          
          Closure of a set F of FDs is the set F+ of all FDs that
          can be inferred from F
          
          
          
          Closure of a set of attributes X concerning F is the 
          set X+ of all attributes that are functionally determined by X
          





           Pseudocode to find Closure of an Attribute
           ---------------------------------------------
                    Determine X+, the closure of X under functional dependency set F
                    X Closure : = will contain X itself;
                    Repeat the process as:
                    old X Closure  : = X Closure;
                    for each functional dependency P → Q in FD set do
                    if X Closure is subset of P then X Closure := X Closure U Q ;
                      Repeat until ( X Closure = old X Closure);
           





      Q.1: 
      
      Consider the relation scheme 
      R = {E, F, G, H, I, J, K, L, M, N} and 
      the set of functional dependencies 
      {{E, F} -> {G}, 
       {F} -> {I, J}, 
       {E, H} -> {K, L}, 
        K -> {M}, 
        L -> {N} on R. 
      
              What is the key for R?

                    Solution:
                    
                    Finding attribute closure of all given options, we get: 
                    {E,F}+ = {EFGIJ}        ≠ R
                    {E,F,H}+ = {EFHGIJKLMN}   = R
                    {E,F,H,K,L}+ = {{EFHGIJKLMN}       = R
                    {E}+ = {E}           ≠ R
                    
                    {EFH}+ and {EFHKL}+ results in set of all attributes  ≠ R, 
                    but EFH is minimal. 
                    
                    So EFH will be candidate key.




       Q.2: 
       
       Consider a relation scheme
       R = (A, B, C, D, E, H) 
       
       on which the following functional dependencies hold: 
       {A–>B, BC–> D, E–>C, D–>A}. 
       
       What are the candidate keys of R?


                 Solution:
                 
                 (AE)+ = {ABECD} which is not set of all attributes. 
                 So AE is not a candidate key. Hence option A and B are wrong. 
                 
                 (AEH)+ = {ABCDEH} 
                 
                 (BEH)+ = {BEHCDA} 
                 
                 (BCH)+ = {BCHDA} which is not set of all attributes. 
                 So BCH is not a candidate key. Hence option C is wrong. 
                 
                 CK : AEH, BEH, DEH 
















====================================================================================
Keys and Functional Dependencie
OR
Finding candidate key
====================================================================================

     Example
     -----------
     
     Consider a relation R(A,B,C,D,E) 
     having a set of FD’s F= { A→BC, CD→E,B→D,E→A}. 
     
     List all the candidate keys of relation R. 
     Also find primary key, prime attributes
     and non-prime attributes.
     




Sol. 
             
             There are 5 attributes, which gives a large number of 
             subsets of R. To reduce the number of subsets to be 
             considered, we should start with single attributes, then
             take subsets mentioned on LHS of all FD’s. 
             
             
             If they are candidate keys, then ignore all subsets 
             having these attributes (2nd condition of candidate key).
             
                     First of all try all individual attributes
                     Try A, then A+
                      = ABCDE = R, So A is a candidate key. 
                     
                     Try B, then B+
                      = BD ≠ R, So B is not a candidate key.
                     
                     Try C, then C+
                      = C ≠ R, So C is not a candidate key. 
                     
                     Try D, then D+
                      = D ≠ R, So D is not a candidate key. 
                     
                     Try E, then E+
                      = ABCDE = R, So E is a candidate key.
                     
                     Now try CD, then CD+ = ABCDE = R, so CD is a candidate key. 
                     
                     You can ignore all the subsets having A, E and CD. 
                     
                     Thus only two subsets are left i.e. BC and BD
                     
                     Try BC, then BC+
                     = ABCDE =R, so BC is a candidate key. 
                     
                     Finaly, try BD, then BD+
                      =BD ≠R, So B is not a candidate key.
                     
                     So, candidate keys of R are A, E, BC and CD.
                     
                     Consider one of them as primary keys.

                     Take BC as a primary key, so Prime Attributes are B and C 
                     and non-prime attributes are A,D and E.
                     




 Example
-----------
 Given R( X Y Z W) and FD= { XYZ → W, XY → ZW and X → YZW

Step 1: Let us calculate the closure of XYZ+ = XYZW (from the method we studied earlier)
Since XYZ closure is determining all the attributes of the table, hence it is Super Key

Step 2: Let us calculate the closure of XY+ = XYZW (from the method we studied earlier)
Since XY closure is determining all the attributes of the table, hence it is Super Key

Step 3: Let us calculate the closure of X+ = XYZW (from the method we studied earlier)
Since X closure is determining all the attributes of the table, hence it is Super Key

As we have talked in the above step only for the super key, not for the candidate key.
Let us see the definition of Candidate Key again (Candidate Key is a Super Key whose no 
proper subset is a superkey)

From the above definition, XYZ is not a candidate key, as in Step 2 and 3 we found
that XY and X are also Super Key (i.e., subset of XYZ are also SK which violate the definition)

XY is not a candidate key, as in Step 3 we found that X is also a Super Key (i.e., subset of XY
are also SK which violate the definition)

X is the Candidate key: As X cannot be further subdivided, or X cannot have any subset.







 Example
-----------
Given R( X Y Z W) and FD= { XY → Z, Z → YW, and W → X }

Step 1: Let us calculate the closure of XY+ = XYZW (from the method we studied earlier)
Since XY closure is determining all the attributes of the table, hence it is Super Key

Step 2: Let us calculate the closure of Z+ = ZYWX (from the method we studied earlier)
Since Z closure is determining all the attributes of the table, hence it is Super Key

Step 3: Let us calculate the closure of W+ = WX (from the method we studied earlier)
Since X closure is not determining all the attributes of the table, hence it is Not Super 
Key, since it is not SK it can never be Candidate key



As we have talked in the above step only for the super key, not for the candidate key.

Let us see the definition of Candidate Key again (Candidate Key is a Super Key whose 
no proper subset is a superkey)

From the above definition XY is a candidate key, as in Step 2 and 3 none of the s
ubsets of XY i.e. either X or Y is Super Key.






 Example
-----------
https://www.javatpoint.com/dbms-candidate-key





 Example
-----------
Let R = (A, B, C, D, E, F) be a relation scheme with the following dependencies-

FD: C → F , E → A, EC → D, A → B
Which of the following is a key for R?

            CD
            EC
            AE
            AC
sol

Step-01:
Determine all essential attributes of the given relation.
Essential attributes of the relation are- C and E.
So, attributes C and E will definitely be a part of every candidate key.

Step-02:
We will check if the essential attributes together can determine all remaining non-essential attributes.
To check, we find the closure of CE.
 
So, we have-
{ CE }+ = { C , E }
        = { C , E , F }                       ( Using C → F )
        = { A , C , E , F }                   ( Using E → A )
        = { A , C , D , E , F }               ( Using EC → D )
        = { A , B , C , D , E , F }           ( Using A → B )




We conclude that CE can determine all the attributes of the given relation.

So, CE is the only possible candidate key of the relation.





Example
-----------
Let R = (A, B, C, D, E) be a relation scheme with the following dependencies-
FD: AB → C, , C → D, B → E

Determine the total number of candidate keys and super keys.

sol
 
AB is the only possible candidate key of the relation.


Example
-----------
Consider the relation scheme R(E, F, G, H, I, J, K, L, M, N) and the set of functional dependencies-
FD : { E, F } → { G }
{ F } → { I , J }
{ E, H } → { K, L }
{ K } → { M }
{ L } → { N }



sol

EFH is the only possible candidate key of the relation.










Example. 
----------

Suppose you are given a relation R(A, B, C, D). 
For each of the following sets 
of FDs, assuming they are the only dependencies that hold for R, 
identify the candidate  key(s) for R. 

1. B→C, D→A. 
2. A→BC, C→AD 
3. A→B, B→C, C→D 


Sol. 

                 1. Candidate key: BD
                 2. Candidate keys: A and C
                 3. Candidate key: A





Example. 
----------

Consider the following relational schema R(A, B, C, D, E) and 
set of functional dependencies AB → E and D → C.

List all superkey(s) for this relation. 
Which of these superkeys form a key (i.e., a minimal superkey) for this relation? 
Justify the answer in terms of functional dependencies and closures.


Sol. 

A superkey is a set of attributes X s.t. X+  = all attributes.
From the FDs above, we can derive:
           {A, B, D}+ = {A, B, C, D}+
                      = {A, B, D, E}+
                      = {A, B, C, D, E}+
                      = {A, B, C, D, E}

Hence, {A,B,D}, {A,B,C,D}, {A,B,D,E}, and {A,B,C,D,E} are all superkeys.

A key is a set of attributes which form a superkey and for which no subset is a superkey. 

In this example, {A,B,D} is the only key










====================================================================================
Normalisation
====================================================================================
Normalisation is a process by which we can decompose or divide any relation into more 
than one relation to remove anomalies in relational database.

It is a step by step process and each step is known as Normal Form.
Normalisation is a reversible process





Normal Form	Description
---------------------------
1NF	
     A relation is in 1NF if it contains an atomic value.

2NF	
     A relation will be in 2NF if it is in 1NF and 
     all non-key attributes are fully functional dependent on the primary key.

3NF	
     A relation will be in 3NF if it is in 2NF and 
     no transition dependency exists.

BCNF	
      A stronger definition of 3NF is known as Boyce Codd's normal form.











====================================================================================
First Normal Form (1NF)
====================================================================================
A relation is in 1NF if it contains an single(atomic) valued attributes/columns.
OR
If a relation contain composite or multi-valued attribute, it violates first normal.

   eg : phone no : 98154789 , 987578  ====> Multivalued, not atomic 
        age: 25 years old ===> single, atomic, not multivalues ==> 1NF



EXAMPLE
----------

        If we have an Employee table in which we store the 
        employee information along with the employee skillset,
        the table will look like this:

+--------+--------------+------------+-----------------------+
| emp_id | emp_name     | emp_mobile | emp_skills            |
+--------+--------------+------------+-----------------------+
|      1 | John Tick    | 9999957773 | Python, JavaScript    |
|      2 | Darth Trader | 8888853337 | HTML, CSS, JavaScript |
|      3 | Rony Shark   | 7777720008 | Java, Linux, C++      |
+--------+--------------+------------+-----------------------+

  The above table has 4 columns:
       
          All the columns have different names.
          
          All the columns hold values of the same type like emp_name 
          has all the names, emp_mobile has all the contact numbers, etc.
          
          The order in which we save data doesn't matter
          
          But the emp_skills column holds multiple comma-separated values, 
          while as per the First Normal form, each column 
          should have a single value.


    Hence the above table fails to pass the First Normal form.
    
           So how do you fix the above table? There are 
           two ways to do this:
           
           Remove the emp_skills column from the Employee 
           table and keep it in some other table.
           
           Or add multiple rows for the employee and each row 
           is linked with one skill.

1. Create Separate tables for Employee and Employee Skills
     So the Employee table will look like this,

          +--------+--------------+------------+
          | emp_id | emp_name     | emp_mobile |
          +--------+--------------+------------+
          |      1 | John Tick    | 9999957773 |
          |      2 | Darth Trader | 8888853337 |
          |      3 | Rony Shark   | 7777720008 |
          +--------+--------------+------------+
          
                    +--------+------------+
                    | emp_id | skill      |
                    +--------+------------+
                    |      1 | JavaScript |
                    |      1 | Python     |
                    |      2 | CSS        |
                    |      2 | HTML       |
                    |      2 | JavaScript |
                    |      3 | C++        |
                    |      3 | Java       |
                    |      3 | Linux      |
                    +--------+------------+


2. Add Multiple rows for Multiple skills
        You can also simply add multiple rows to add multiple skills. 
        This will lead to repetition of the data, but that 
        can be handled as you further Normalize your 
        data using the Second Normal form and the Third Normal form.


               +--------+--------------+-----------+--------------+
               emp_id  	  emp_name	      emp_mobile	  emp_skill
               +--------+--------------+-----------+--------------+
               1	         John Tick	     9999957773	  Python
               1	         John Tick	     9999957773	  JavaScript
               2	         Darth Trader  	8888853337  	HTML
               2	         Darth Trader  	8888853337	  CSS
               2	         Darth Trader  	8888853337	  JavaScript
               3	         Rony Shark    	7777720008	  Java
               3	         Rony Shark	    7777720008	  Linux
               3	         Rony Shark	    7777720008	  C++
               +--------+--------------+-----------+--------------+





EXAMPLE
----------
In the below table Course is a multi-valued attribute 
so it is not in 1NF. 



           +-----+----+--------+
             ID   Name   Courses
           +-----+----+--------+
              1    A      c1, c2
              2    E      c3
              3    M      C2, c3
           +-----+----+--------+

Now Table is in 1NF as there is no multi-valued attribute
            +-----+----+--------+
             ID   Name   Course
            +-----+----+--------+
              1    A       c1
              1    A       c2
              2    E       c3
              3    M       c2
              3    M       c3
            +-----+----+--------+





EXAMPLE
----------

student
+--------+--------+----------------+--------------+---------+
| stu_no | name   | phone          | district     | country |
+--------+--------+----------------+--------------+---------+
|      1 | ram    | 1234 7894 8521 | palpa        | nepal   |
|      2 | sita   | 1598           | palpa butwal | nepal   |
|      3 | laxman | 9898           |  butwal      | nepal   |
+--------+--------+----------------+--------------+---------+

to 1 NF

         +--------+--------+-----------+-----------+---------+
         | stu_no | name   | district1 | district2 | country |
         +--------+--------+-----------+-----------+---------+
         |      1 | ram    | palpa     | NULL      | nepal   |
         |      2 | sita   | palpa     | butwal    | nepal   |
         |      3 | laxman | butwal    | NULL      | nepal   |
         +--------+--------+-----------+-----------+---------+
         
         +--------+-------------+-------------+-------------+
         | stu_no | phone_part1 | phone_part2 | phone_part3 |
         +--------+-------------+-------------+-------------+
         |      1 | 1234        | 7894        | 8521        |
         |      2 | 1598        |             |             |
         |      3 | 9898        |             |             |
         +--------+-------------+-------------+-------------+




-- Create the student table
CREATE TABLE student (
    stu_no INT PRIMARY KEY,
    name VARCHAR(255),
    district1 VARCHAR(255),
    district2 VARCHAR(255),
    country VARCHAR(255)
);

-- Create the phone table with 
separate columns for each part 
of the phone number
CREATE TABLE phone (
    stu_no INT,
    phone_part1 VARCHAR(4),
    phone_part2 VARCHAR(4),
    phone_part3 VARCHAR(4),
    PRIMARY KEY (stu_no, phone_part1, phone_part2, phone_part3),
    FOREIGN KEY (stu_no) REFERENCES student(stu_no)
);

-- Insert data into the student table
INSERT INTO student (stu_no, name, district1, district2, country)
VALUES
(1, 'ram', 'palpa', NULL, 'nepal'),
(2, 'sita', 'palpa', 'butwal', 'nepal'),
(3, 'laxman', 'butwal', NULL, 'nepal');

-- Insert data into the phone 
table by splitting the phone number
INSERT INTO phone (stu_no, phone_part1, phone_part2, phone_part3)
VALUES
(1, '1234', '7894', '8521'),
(2, '1598', NULL, NULL),
(3, '9898', NULL, NULL);
INSERT INTO phone (stu_no, phone_part1, phone_part2, phone_part3) VALUES
    (1, '1234', '7894', '8521'),
    (2, '1598','' ,'')
    (3, '9898','' ,'');











====================================================================================
Second Normal Form (2NF)
====================================================================================
A relation will be in 2NF if it is in 1NF 
and 
all non-prime attributes are fully functional dependent on the candidte key(PK).
OR
There shoud be no partial dependency

     R(ABC)
          CK <- NPA
          eg AB <- A  (proper subset A or B)
                <- B
          
          then  A or B -> C  (partial dependnt)








EXAMPLE
---------- 2NF ?

TEACHER 
---------------------------------------------
TEACHER_ID	      SUBJECT	       TEACHER_AGE
---------------------------------------------
  25	              Chemistry	      30
  25	              Biology	        30
  47	              English	        35
  83	              Math	           38
  83	              Computer	       38
---------------------------------------------


In the given table,
non-prime attribute TEACHER_AGE is dependent on TEACHER_ID which 
is a proper subset of a candidate key. 

That's why it violates the rule for 2NF.

TEACHER_ID <- TEACHER_AGE

To convert the given table into 2NF, we
decompose it into two tables:



                  TEACHER_DETAIL 
                  ---------------------------
                  TEACHER_ID	   TEACHER_AGE
                  ---------------------------
                       25	        30
                       47	        35
                       83	        38
                  ---------------------------


                        TEACHER_SUBJECT 
                        ---------------------------
                        TEACHER_ID	        SUBJECT
                        ---------------------------
                                25	       Chemistry
                                25	       Biology
                                47	       English
                                83	       Math
                                83	       Computer
                        ---------------------------



EXAMPLE
----------
EmployeeProjectDetail
----------------------------------------------------------------------
Employee Code	    Project ID	     Employee Name	    Project Name
----------------------------------------------------------------------
     101	           P03	             John           	Project103
     101           	P01	             John	           Project101
     102	           P04	             Ryan	           Project104
     103	           P02             	Stephanie	      Project102
----------------------------------------------------------------------

In the above table, 
the prime attributes of the table are Employee Code and Project ID.

We have partial dependencies in this table because 
Employee Name can be determined by Employee Code

and 
Project Name can be determined by Project ID.

Thus, the above relational table violates the rule of 2NF.

----------------------------------------------------------------------
Employee Code	    Project ID	     Employee Name	    Project Name
----------------------------------------------------------------------
     PA              PA             NPA                NPA


Employee Code <- Employee Name
   PA                 NPA


Project ID.<- Project Name
   PA                 NPA




To remove partial dependencies from this table 
and normalize it into second normal form, 
we can decompose the <EmployeeProjectDetail> table

into the following three tables:

                    EmployeeDetail
                    ----------------------------------
                    Employee Code	 Employee Name
                    ----------------------------------
                        101	       John
                        101	       John
                        102	       Ryan
                        103	       Stephanie
                    ----------------------------------
                    
                    EmployeeProject
                    ----------------------------------
                    Employee Code	      Project ID
                    ----------------------------------
                          101	            P03
                          101	            P01
                          102	            P04
                          103            	P02
                    ----------------------------------
                    
                    
                    ProjectDetail
                    ----------------------------------
                    Project ID	       Project Name
                    ----------------------------------
                          P03	         Project103
                          P01	         Project101
                          P04	         Project104
                          P02	         Project102

----------------------------------


the above tables satisfy the following 
two rules of 2NF as they are in 1NF and 
every non-prime attribute is fully dependent on the primary key.








EXAMPLE
----------

 Let’s say a school wants to store the 
data of teachers and the subjects they teach. 
 

Since a teacher can teach more than one subjects, the table 
can have multiple rows for a same teacher.


----------------------------------------------
Teacher_Id	    Subject	    Teacher_Age
----------------------------------------------
       111	      Maths	       38
       111	      Physics	     38
       222	      Biology	     38
       333	      Physics	     40
       333	      Chemistry	   40
----------------------------------------------


Candidate Keys: {Teacher_Id, Subject}
Non prime attribute: Teacher_Age

This table is in 1 NF because each attribute has atomic values. 

However, it is not in 2NF 

because non prime attribute Teacher_Age is dependent on 
Teacher_Id alone which is a proper subset of candidate key. 

This violates the rule for 2NF as the rule says 
“no non-prime attribute is dependent on the proper subset of 
any candidate key of the table”.

To make the table complies with 2NF we can disintegrate it in two tables like this:



          Teacher_Details
          ----------------------------
          Teacher_Id     	Teacher_Age
          ----------------------------
                111	       38
                222	       38
                333	       40
          ----------------------------


           Teacher_Subject
           ----------------------------
           Teacher_Id	        Subject
           ----------------------------
                 111	          Maths
                 111          	Physics
                 222           Biology
                 333	          Physics
                 333	          Chemistry
           ----------------------------


Now the tables are in Second normal form (2NF). 




EXAMPLE
----------
EXAMPLE
----------



EXAMPLE
----------


















====================================================================================
Third Normal Form (3NF)
====================================================================================

A relation will be in 3NF if it is in 2NF and 
     no transition dependency exists.

A -> B
B -> C
then A -> C   i.e transitive dpendency















example
------------
        -----------------------------
        roll_no  provinence   city
        -----------------------------
        1          lumbini    butwal
        2          gandaki    pokhara
        3          lumbini    butwal
        4          gandaki    pokhara
        5          koshi      ktm
        -----------------------------



1. First Normal Form (1NF)
         A table is in 1NF if:
         
         All column values are atomic (indivisible).
         Each column contains only one value per row.




2. Second Normal Form (2NF)
           A table is in 2NF if:
           
           It is in 1NF.
           There are no partial dependencies of any column on
           the primary key (i.e., no non-key attribute is dependent
           on part of a composite primary key).
           
           Here, let's assume roll_no is the primary key.
           Each roll_no uniquely identifies a student, and both
           provinence and city are fully dependent on roll_no.
           Therefore, the table is in 2NF because all non-key 
           attributes (provinence, city) depend on the entire 
           primary key (roll_no), which is not a composite key.



3. Third Normal Form (3NF)
           A table is in 3NF if:
           
           It is in 2NF.
             There are no transitive dependencies, meaning 
             non-key attributes do not depend on other non-key attributes.
           
           
           In this table:
                provinence and city are both non-key attributes.
                There is a potential transitive dependency where
                city might depend on provinence. For example, the 
                province "Lumbini" always corresponds to the city
                "Butwal" (although there is a typo in "butwl"), and 
                "Gandaki" always corresponds to "Pokhara".
           
      



        Original Table
        -----------------------------
        roll_no  provinence   city
        -----------------------------
        1          lumbini    butwal
        2          gandaki    pokhara
        3          lumbini    butwal
        4          gandaki    pokhara
        5          koshi      ktm
        -----------------------------
      


           
            Table student
                  -----------------------------
                   roll_no  provinence   
                   -----------------------------
                   1          lumbini    
                   2          gandaki    
                   3          lumbini    
                   4          gandaki    
                   5          koshi      
                   -----------------------------
           
           New Table: ProvinceCity
                   -----------------------------
                     provinence   city
                   -----------------------------
                     lumbini    butwal
                     gandaki    pokhara
                     koshi      ktm
                   -----------------------------
           


                    here, PK = CK = roll_no
                       FD : roll_no -> provinence, city
                            provinence -> city
                    
                    so, roll_no -> provinence, provinence -> city
                      then      roll_no -> city 
                                i.e transitive dpendency, not 3NF
                    
                    since : PK = CK = roll_no   i.e PA
                               roll_no -> city  i.e NPA -> NPA , voilates 3nf








EXAMPLE
----------
  R(ABCD)
  FD: AB-> C, C-> D

        sol
        CK = AB    PA = AB     NPA = CD
        
        
        here   AB+ = AB C D      = R
               PA -> PA or NPA      ok for 3NF
        
        but     C -> D
               NPA-> NPA            not 3nf




EXAMPLE
----------
EmployeeDetail
--------------------------------------------------------------------------------
Employee Code     	Employee Name	     Employee Zipcode	       Employee City
--------------------------------------------------------------------------------
        101	          John	               110033	               Model Town
        101	          John	               110044	               Badarpur
        102	          Ryan	               110028	               Naraina
        103	          Stephanie	          110064	               Hari Nagar
--------------------------------------------------------------------------------

           In 3NF, we remove transitive dependencies by 
           ensuring that every non-prime attribute 
           is non-transitively dependent on the primary key.
           
           
           The above table is not in 3NF because it has 
           Employee Code -> Employee City transitive dependency because:
           
                     Employee Code -> Employee Zipcode
                     Employee Zipcode -> Employee City
           
           Also, Employee Zipcode is not a super key and Employee City is 
           not a prime attribute.
           
           To remove transitive dependency from this table and normalize
           it into the third normal form, we can decompose 
           the <EmployeeDetail> table into the following two tables:
           


         EmployeeDetail
         -----------------------------------------------------
         Employee Code	   Employee Name	   Employee Zipcode
         -----------------------------------------------------
              101          	John	            110033
              101	          John	            110044
              102	          Ryan	            110028
              103	          Stephanie	       110064
         -----------------------------------------------------


               EmployeeLocation
               ------------------------------------
               Employee Zipcode     	Employee City
               ------------------------------------
                     110033	           Model Town
                     110044	           Badarpur
                     110028	           Naraina
                     110064	           Hari Nagar
               ------------------------------------

        Thus, we’ve converted the <EmployeeDetail> table into 3NF
        by decomposing it into <EmployeeDetail> and <EmployeeLocation> 
        tables as they are in 2NF and they don’t 
        have any transitive dependency.
        














EXAMPLE
----------



EXAMPLE
----------



EXAMPLE
----------

====================================================================================
BCNF
====================================================================================
A stronger definition of 3NF is known as Boyce Codd's normal form.

LHS of each FD should be CK or SK

LHS (CK or SK ) , but RHS ( PK or NPK , doesnt matter)



EXAMPLE
----------

-----------------------------------------------
Roll No      	Name	        Voter ID	      Age
-----------------------------------------------
    001	    Aarav Gurung	  NPL123456789	  25
    002	    Maya Shah	     NPL987654321	  22
    003	    Raj Thapa	     NPL456789012	  28
    004	    Priya Rai	     NPL321654987	  20
    005	    Arjun RAi     	NPL654321789	  30
    006	    Sita Acharya  	NPL789012345	  26
-----------------------------------------------

CK  = Roll No ,  Voter ID	     
FD:
           Roll No -> Name	
           Roll No -> Voter ID
           Voter ID	->  Age
           Voter ID	->  Roll No

LHS (CK or SK ) , but RHS ( PK or NPK , doesnt matter)

           Roll No -> Name	
            CK                          ok
           Roll No -> Voter ID
             CK                         ok
           Voter ID	->  Age
             CK                         ok
           Voter ID	->  Roll No
              CK                         ok



                        is in BCNF 






OR
-----

Now, let's check the functional dependencies:

          Roll No → Name, Voter ID, Age

               Roll No is the primary key, so 
               this is trivially satisfied.


          Voter ID → Name, Age

                Voter ID is not a superkey since two 
                people may have the same Voter ID. 
                Therefore, this violates BCNF.



To bring the table into BCNF, we need 
to decompose it. Let's create two tables:

Table 1: (Roll No, Name, Age)
Table 2: (Voter ID, Name)

              Table 1: (Roll No, Name, Age)
           -----------------------------------
           Roll No      	Name	        	  Age
           -----------------------------------
               001	    Aarav Gurung	     25
               002	    Maya Shah	     	  22
               003	    Raj Thapa	     	  28
               004	    Priya Rai	     	  20
               005	    Arjun RAi     		  30
               006	    Sita Acharya  		  26
           ------------------------------------



                         Table 2: (Voter ID, Name)
                   -----------------------------------------
                   Voter ID	             Name
                   -----------------------------------------
                   NPL123456789      	  Aarav Gurung
                   NPL987654321     	   Maya Shah
                   NPL456789012        	Raj Thapa
                   NPL321654987	        Priya Rai
                   NPL654321789      	  Arjun Bhattarai
                   NPL789012345	        Sita Acharya
                   -----------------------------------------







====================================================================================
BIM 2023 April
====================================================================================

https://bimstudynotes.com/database-management-system-tu-paper-bim-study-notes/

Question: Determine the normal form of the above student table. 
If it is not in 3NF, normalize it to 3NF.

+-----------+-------------+----------+-------------------+--------+------------------------+
| StudentID | StudentName | CourseID | Course Name       | Credit | Contact_No             |
+-----------+-------------+----------+-------------------+--------+------------------------+
| 101       | Ram         | IT220    | DBMS              | 3      | 9841XXXXXX, 5573XXXX   |
| 102       | Sita        | IT220    | DBMS              | 3      | 9950XXXXXX             |
| 103       | John        | IT218    | DSA with JAVA     | 3      | 9371XXXXXX, 2365XXXX   |
| 104       | Jenny       | ECO201   | Micro Economics   | 3      | 9985XXXXXX, 4395XXXX   |
+-----------+-------------+----------+-------------------+--------+------------------------+




Answer:


Step 1: Check for First Normal Form (1NF)

        Requirement for 1NF:
        All columns must contain atomic (indivisible) values.
        Each entry in a column must be unique.
        
        Analysis:
        The Contact_No column contains multiple phone numbers
        in some rows (e.g., 9841XXXXXX, 5573XXXX for StudentID 101),
        which means it is not atomic.
        
        Conclusion:
        The table is not in 1NF because it has a non-atomic
        field (Contact_No).


        Conversion to 1NF:
        To convert to 1NF, separate each contact number
        into individual rows to ensure all values are atomic.
        
        1NF Table Structure:

        +-----------+-------------+----------+-------------------+--------+-------------+
        | StudentID | StudentName | CourseID | Course Name       | Credit | Contact_No  |
        +-----------+-------------+----------+-------------------+--------+-------------+
        | 101       | Ram         | IT220    | DBMS              | 3      | 9841XXXXXX  |
        | 101       | Ram         | IT220    | DBMS              | 3      | 5573XXXX    |
        | 102       | Sita        | IT220    | DBMS              | 3      | 9950XXXXXX  |
        | 103       | John        | IT218    | DSA with JAVA     | 3      | 9371XXXXXX  |
        | 103       | John        | IT218    | DSA with JAVA     | 3      | 2365XXXX    |
        | 104       | Jenny       | ECO201   | Micro Economics   | 3      | 9985XXXXXX  |
        | 104       | Jenny       | ECO201   | Micro Economics   | 3      | 4395XXXX    |
        +-----------+-------------+----------+-------------------+--------+-------------+













Step 2: Check for Second Normal Form (2NF)


             Requirement for 2NF:
             The table must be in 1NF.
             All non-key attributes must be fully functionally 
             dependent on the primary key (no partial dependency).
             
             
             Analysis:
             Assuming StudentID is the primary key:
             The non-key attributes (StudentName, CourseID, Course Name,
             Credit, Contact_No) depend on StudentID.
             However, CourseID determines Course Name and Credit, 
             showing a partial dependency when combined with StudentID.
             
             
             Conclusion:
             The table is in 1NF but not in 2NF because 
             Course Name and Credit are partially dependent on CourseID
             rather than the entire primary key (StudentID).
             
             
             Conversion to 2NF:
             To convert to 2NF, remove partial dependencies by 
             creating separate tables for Course information.
             
             2NF Table Structures:
             
             Student Table:
             +-----------+-------------+-------------+
             | StudentID | StudentName | Contact_No  |
             +-----------+-------------+-------------+
             | 101       | Ram         | 9841XXXXXX  |
             | 101       | Ram         | 5573XXXX    |
             | 102       | Sita        | 9950XXXXXX  |
             | 103       | John        | 9371XXXXXX  |
             | 103       | John        | 2365XXXX    |
             | 104       | Jenny       | 9985XXXXXX  |
             | 104       | Jenny       | 4395XXXX    |
             +-----------+-------------+-------------+



            Course Table:
            +----------+-------------------+--------+
            | CourseID | Course Name       | Credit |
            +----------+-------------------+--------+
            | IT220    | DBMS              | 3      |
            | IT218    | DSA with JAVA     | 3      |
            | ECO201   | Micro Economics   | 3      |
            +----------+-------------------+--------+



            StudentCourse Table:
            +-----------+----------+
            | StudentID | CourseID |
            +-----------+----------+
            | 101       | IT220    |
            | 102       | IT220    |
            | 103       | IT218    |
            | 104       | ECO201   |
            +-----------+----------+








Step 3: Check for Third Normal Form (3NF)
           
           Requirement for 3NF:
           The table must be in 2NF.
           There should be no transitive 
           dependencies (non-key attributes should 
           not depend on other non-key attributes).
           
           
           Analysis:
           In the 2NF tables, all non-key attributes 
           are directly dependent on the primary key
           of each table.
           There are no transitive dependencies; all
           attributes are fully functionally dependent 
           on their respective primary keys.
           
           
           Conclusion:
           The tables are now in 3NF.
           
           
           Final 3NF Tables:
           Student Table (3NF):
           


            
            Student Table (3NF):
            +-----------+-------------+-------------+
            | StudentID | StudentName | Contact_No  |
            +-----------+-------------+-------------+
            | 101       | Ram         | 9841XXXXXX  |
            | 101       | Ram         | 5573XXXX    |
            | 102       | Sita        | 9950XXXXXX  |
            | 103       | John        | 9371XXXXXX  |
            | 103       | John        | 2365XXXX    |
            | 104       | Jenny       | 9985XXXXXX  |
            | 104       | Jenny       | 4395XXXX    |
            +-----------+-------------+-------------+
            
            Course Table (3NF):
            +----------+-------------------+--------+
            | CourseID | Course Name       | Credit |
            +----------+-------------------+--------+
            | IT220    | DBMS              | 3      |
            | IT218    | DSA with JAVA     | 3      |
            | ECO201   | Micro Economics   | 3      |
            +----------+-------------------+--------+
            
            
            StudentCourse Table (3NF):
            +-----------+----------+
            | StudentID | CourseID |
            +-----------+----------+
            | 101       | IT220    |
            | 102       | IT220    |
            | 103       | IT218    |
            | 104       | ECO201   |
            +-----------+----------+
            
            
            The student table has now been successfully 
            normalized to Third Normal Form (3NF), eliminating 
            all partial and transitive dependencies.
            









====================================================================================
14 august 2025 BIM new que
====================================================================================



| Student_ID | Course_id | Student_Name | Course_Name | Grade | Teacher | Teacher Email    |
|------------|-----------|--------------|-------------|-------|---------|------------------|
| 100        | 10        | Ram          | SQL         | A     | Ashok   | ashok@cnn.com    |
| 200        | 10        | Sita         | SQL         | B     | Ashok   | ashok@cnn.com    |
| 100        | 20        | Ram          | Python      | A     | Om      | om@ntv.com       |
| 200        | 20        | Sita         | Python      | A     | Om      | om@ntv.com       |
| 300        | 10        | Hari         | SQL         | C     | Ashok   | ashok@cnn.com    |
| 400        | 10        | Gita         | SQL         | C     | Ashok   | ashok@cnn.com    |
| 400        | 20        | Gita         | Python      | C     | Om      | om@ntv.com       |




1. First Normal Form (1NF)
---------------------------------
      Each table cell should contain a single value
      Each record needs to be unique
      Result: The table is already in 1NF as it meets these requirements.




2. Second Normal Form (2NF)
 ---------------------------------     
      Must be in 1NF
            All non-key attributes must depend on the entire primary key
      
      Analysis:
            The primary key is composite: (Student_ID, Course_id)
            Student_Name depends only on Student_ID (partial dependency)
            Course_Name, Teacher, and Teacher_Email depend only on Course_id (partial dependency)
            Only Grade depends on the full primary key

      Solution: Decompose into three tables:
              Students (Student_ID, Student_Name)
              Courses (Course_id, Course_Name, Teacher, Teacher_Email)
              Enrollments (Student_ID, Course_id, Grade)

Students:
| Student\_ID | Student\_Name |
| ----------- | ------------- |
| 100         | Ram           |
| 200         | Sita          |
| 300         | Hari          |
| 400         | Gita          |


Courses:
| Course\_ID | Course\_Name | Teacher | Teacher\_Email    
| ---------- | ------------ | ------- | -----------------
| 10         | SQL          | Ashok   | [ashok@cnn.com]
| 20         | Python       | Om      | [om@ntv.com]



Enrollments:
| Student\_ID | Course\_ID | Grade |
| ----------- | ---------- | ----- |
| 100         | 10         | A     |
| 200         | 10         | B     |
| 100         | 20         | A     |
| 200         | 20         | A     |
| 300         | 10         | C     |
| 400         | 10         | C     |
| 400         | 20         | C     |





3. Third Normal Form (3NF)
---------------------------------
            Requirements:
                    Must be in 2NF
                    No transitive dependencies (non-key attributes shouldn't 
                                              depend on other non-key attributes)
            
            Analysis:
                  In the Courses table, Teacher_Email depends on Teacher (not directly on Course_id)
                  This is a transitive dependency
            
            Solution: Further decompose the Courses table:
                  Courses (Course_id, Course_Name, Teacher_ID)
                  Teachers (Teacher_ID, Teacher_Name, Teacher_Email)





Teachers
| Teacher\_ID | Teacher\_Name | Teacher\_Email                        |
| ----------- | ------------- | --------------------
| T1          | Ashok         | [ashok@cnn.com]
| T2          | Om            | [om@ntv.com]




Courses
| Course\_ID | Course\_Name | Teacher\_ID |
| ---------- | ------------ | ----------- |
| 10         | SQL          | T1          |
| 20         | Python       | T2          |






Boyce-Codd Normal Form (BCNF)
---------------------------------
        Requirements:
              Must be in 3NF
              For every functional dependency X → Y, X must be a superkey
        
        Analysis:
            All tables are already in BCNF because:
                  In Students: Student_ID is the key
                  In Teachers: Teacher_ID is the key
                  In Courses: Course_id is the key
                  In Enrollments: (Student_ID, Course_id) is the key








---------------------------------
Final Normalized Schema:
---------------------------------

        
        Students (Student_ID, Student_Name)
              PK: Student_ID
        
        Teachers (Teacher_ID, Teacher_Name, Teacher_Email)
              PK: Teacher_ID
        
        Courses (Course_id, Course_Name, Teacher_ID)
              PK: Course_id
              FK: Teacher_ID references Teachers(Teacher_ID)
        
        Enrollments (Student_ID, Course_id, Grade)
              PK: (Student_ID, Course_id)
              FK: Student_ID references Students(Student_ID)
              FK: Course_id references Courses(Course_id)




Students:
| Student\_ID | Student\_Name |
| ----------- | ------------- |
| 100         | Ram           |
| 200         | Sita          |
| 300         | Hari          |
| 400         | Gita          |



Enrollments:
| Student\_ID | Course\_ID | Grade |
| ----------- | ---------- | ----- |
| 100         | 10         | A     |
| 200         | 10         | B     |
| 100         | 20         | A     |
| 200         | 20         | A     |
| 300         | 10         | C     |
| 400         | 10         | C     |
| 400         | 20         | C     |




Teachers
| Teacher\_ID | Teacher\_Name | Teacher\_Email                        |
| ----------- | ------------- | --------------------
| T1          | Ashok         | [ashok@cnn.com]
| T2          | Om            | [om@ntv.com]




Courses
| Course\_ID | Course\_Name | Teacher\_ID |
| ---------- | ------------ | ----------- |
| 10         | SQL          | T1          |
| 20         | Python       | T2          |











====================================================================================
BIM 2018
====================================================================================



ProjNum | ProjName   | EmpName         | Job_Class | Charge_Hour | Hours_Worked | Total_Charge
15      | Evergreen  | Prithvi         | Engineer  | $25         | 145          | 3625
15      | Evergreen  | Nishi           | DBA       | $18         | 220          | 3960
15      | Evergreen  | Rizvi, Mokshada | DBA,DBA   | $18         | 110          | 1980
18      | Kulekhani  | Prithvi         | Engineer  | $25         | 220          | 5500
18      | Kulekhani  | Akshat          | DBA       | $18         | 150          | 2700




SOLUTion
-----------



Unnormalized Table (UNF)
(Repeating groups: multiple employees with combined names like "Rizvi, Mokshada")

    ProjNum | ProjName   | EmpName         | Job_Class | Charge_Hour | Hours_Worked | Total_Charge
    15      | Evergreen  | Prithvi         | Engineer  | $25         | 145          | 3625
    15      | Evergreen  | Nishi           | DBA       | $18         | 220          | 3960
    15      | Evergreen  | Rizvi, Mokshada | DBA,DBA   | $18         | 110          | 1980
    18      | Kulekhani  | Prithvi         | Engineer  | $25         | 220          | 5500
    18      | Kulekhani  | Akshat          | DBA       | $18         | 150          | 2700




Step 1 – 1NF (First Normal Form)
--------------------------------------------
  Remove repeating groups (split multiple names and multiple job classes into separate rows).
  Ensure each field has atomic values.

ProjNum | ProjName   | EmpName   | Job_Class | Charge_Hour | Hours_Worked | Total_Charge
15      | Evergreen  | Prithvi   | Engineer  | $25         | 145          | 3625
15      | Evergreen  | Nishi     | DBA       | $18         | 220          | 3960
15      | Evergreen  | Rizvi     | DBA       | $18         | 110          | 1980
15      | Evergreen  | Mokshada  | DBA       | $18         | 110          | 1980
18      | Kulekhani  | Prithvi   | Engineer  | $25         | 220          | 5500
18      | Kulekhani  | Akshat    | DBA       | $18         | 150          | 2700




Step 2 – 2NF (Second Normal Form)
--------------------------------------------
Identify composite key: (ProjNum, EmpName)
      Remove partial dependencies (attributes that depend only on part of the composite key).
      ProjName depends only on ProjNum.
      Job_Class and Charge_Hour depend only on EmpName.

Projects
ProjNum | ProjName
15      | Evergreen
18      | Kulekhani


Employees
EmpName   | Job_Class | Charge_Hour
Prithvi   | Engineer  | $25
Nishi     | DBA       | $18
Rizvi     | DBA       | $18
Mokshada  | DBA       | $18
Akshat    | DBA       | $18



Work_Assignment
ProjNum | EmpName   | Hours_Worked | Total_Charge
15      | Prithvi   | 145          | 3625
15      | Nishi     | 220          | 3960
15      | Rizvi     | 110          | 1980
15      | Mokshada  | 110          | 1980
18      | Prithvi   | 220          | 5500
18      | Akshat    | 150          | 2700





Step 3 – 3NF (Third Normal Form)
--------------------------------------------
    Remove transitive dependencies (non-key attributes depending on other non-key attributes).

    Total_Charge = Charge_Hour × Hours_Worked → derived attribute → remove it from storage.


Projects
ProjNum | ProjName
15      | Evergreen
18      | Kulekhani

Employees
EmpName   | Job_Class | Charge_Hour
Prithvi   | Engineer  | $25
Nishi     | DBA       | $18
Rizvi     | DBA       | $18
Mokshada  | DBA       | $18
Akshat    | DBA       | $18


Work_Assignment
ProjNum | EmpName   | Hours_Worked
15      | Prithvi   | 145
15      | Nishi     | 220
15      | Rizvi     | 110
15      | Mokshada  | 110
18      | Prithvi   | 220
18      | Akshat    | 150









Step 4 – BCNF (Boyce-Codd Normal Form)

In BCNF, for every functional dependency X → Y, X must be a superkey.
        Current structure already satisfies BCNF:
        ProjNum → ProjName (ProjNum is key in Projects)
        EmpName → Job_Class, Charge_Hour (EmpName is key in Employees)
        


Projects
ProjNum | ProjName
15      | Evergreen
18      | Kulekhani



Employees
EmpName   | Job_Class | Charge_Hour
Prithvi   | Engineer  | $25
Nishi     | DBA       | $18
Rizvi     | DBA       | $18
Mokshada  | DBA       | $18
Akshat    | DBA       | $18





Work_Assignment
ProjNum | EmpName   | Hours_Worked
15      | Prithvi   | 145
15      | Nishi     | 220
15      | Rizvi     | 110
15      | Mokshada  | 110
18      | Prithvi   | 220
18      | Akshat    | 150






====================================================================================
WORK @ HW CW
====================================================================================

Table: Patient Treatment Data

    PatNum | PatName          | DocName          | Specialty       | Fee_Per_Session | Sessions | Total_Fee
    101    | Ramesh Thapa     | Dr. Koirala      | Cardiologist    | $50             | 5        | 250
    101    | Ramesh Thapa     | Dr. Sharma       | Physiotherapist | $30             | 3        | 90
    102    | Anita Shrestha   | Dr. Koirala      | Cardiologist    | $50             | 4        | 200
    103    | Suresh Bhandari  | Dr. Sharma       | Physiotherapist | $30             | 6        | 180
    103    | Suresh Bhandari  | Dr. Lama, Dr. Rai| Surgeon, Surgeon| $100            | 2        | 200
  



Table: Guest Booking Data

      BookingID | GuestName       | RoomNo | RoomType  | Rate_Per_Night | Nights_Stay | Total_Charge
      B01       | Sunita Pandey   | 101    | Deluxe    | $120           | 3           | 360
      B01       | Sunita Pandey   | 202    | Suite     | $200           | 2           | 400
      B02       | Bikash Ghimire  | 101    | Deluxe    | $120           | 4           | 480
      B03       | Anil Khadka     | 202    | Suite     | $200           | 3           | 600
      B03       | Anil Khadka     | 303, 304| Standard, Standard | $80 | 1 | 80





Table: Vehicle Hire Data


        HireID | CustomerName     | DriverName      | VehicleType   | Rate_Per_Hour | Hours_Hired | Total_Fare
        H01    | Rajesh Adhikari  | Ram Bahadur     | Sedan         | $15           | 8           | 120
        H01    | Rajesh Adhikari  | Mohan Shrestha  | SUV           | $20           | 5           | 100
        H02    | Laxmi K.C.       | Ram Bahadur     | Sedan         | $15           | 6           | 90
        H03    | Kiran Thapa      | Mohan Shrestha  | SUV           | $20           | 4           | 80
        H03    | Kiran Thapa      | Suman Lama, Hari Gurung | Minibus, Minibus | $30 | 3 | 90
        



====================================================================================

====================================================================================



====================================================================================

====================================================================================



====================================================================================

====================================================================================



====================================================================================

====================================================================================



====================================================================================

====================================================================================



====================================================================================

====================================================================================



====================================================================================

====================================================================================



====================================================================================

====================================================================================



====================================================================================

====================================================================================



====================================================================================

====================================================================================



====================================================================================

====================================================================================



====================================================================================

====================================================================================



====================================================================================

====================================================================================



====================================================================================

====================================================================================



====================================================================================

====================================================================================



====================================================================================

====================================================================================



====================================================================================

====================================================================================



====================================================================================

====================================================================================



====================================================================================

====================================================================================



====================================================================================

====================================================================================



====================================================================================

====================================================================================



====================================================================================

====================================================================================



====================================================================================

====================================================================================



====================================================================================

====================================================================================



====================================================================================

====================================================================================



====================================================================================

====================================================================================



====================================================================================

====================================================================================



====================================================================================

====================================================================================



====================================================================================

====================================================================================



====================================================================================

====================================================================================



====================================================================================

====================================================================================



====================================================================================

====================================================================================



====================================================================================

====================================================================================



====================================================================================

====================================================================================



====================================================================================

====================================================================================



====================================================================================

====================================================================================



====================================================================================

====================================================================================



====================================================================================

====================================================================================



