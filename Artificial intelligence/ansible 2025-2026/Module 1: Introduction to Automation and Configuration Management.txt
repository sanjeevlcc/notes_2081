

*****************************************************************************************
*****************************************************************************************
*****************************************************************************************



Module 1: Introduction to Automation and Configuration Management


Key Topics
      Concept of IT Automation
      What is Configuration Management
      Benefits of automation tools (Ansible, Puppet, Chef, SaltStack)
      Why choose Ansible (agentless, YAML, SSH-based)
      Overview of DevOps and Infrastructure as Code (IaC)
      Comparison: Manual vs Automated provisioning


Learning Outcomes
    Understand automation fundamentals
    Explain Ansible‚Äôs role in DevOps lifecycle







üß™ Module 1 ‚Äì Lab Topics: Introduction to Automation and Configuration Management

| **Lab No.** | **Lab Title / Focus Area**                                                                           |
| ----------- | ---------------------------------------------------------------------------------------------------- |
| **Lab 1**   | Exploring Traditional vs. Automated Configuration ‚Äî Manual Setup vs. Scripted Setup                  |
| **Lab 2**   | Understanding Automation Tools: Comparing Ansible, Puppet, Chef, and SaltStack (Feature Exploration) |
| **Lab 3**   | Installing and Verifying Ansible on a Control Node                                                   |
| **Lab 4**   | Setting Up Managed Nodes and SSH Key-Based Authentication                                            |
| **Lab 5**   | First Ansible Command ‚Äî Using the `ping` Module to Verify Connectivity                               |
| **Lab 6**   | Creating and Managing an Ansible Inventory File (Static Hosts)                                       |
| **Lab 7**   | Running Simple Ad-hoc Commands for Package and Service Management                                    |
| **Lab 8**   | Editing and Understanding YAML Syntax for Automation Tasks                                           |
| **Lab 9**   | Configuring and Viewing the `ansible.cfg` File (Defaults and Overrides)                              |
| **Lab 10**  | Exploring Ansible Facts ‚Äî Gathering System Information from Remote Nodes                             |
| **Lab 11**  | Writing a Basic Ansible Playbook for System Update and Verification                                  |
| **Lab 12**  | Demonstrating Agentless Automation: Running Tasks via SSH Without Agents                             |
| **Lab 13**  | Comparing Manual Server Configuration vs. Automated Ansible Playbook Execution                       |
| **Lab 14**  | Introduction to Infrastructure as Code (IaC) ‚Äî Concept Demo Using Simple Ansible Scripts             |
| **Lab 15**  | Integrating Ansible with DevOps Workflow ‚Äî Automating a Sample Deployment Pipeline Overview          |




*****************************************************************************************
*****************************************************************************************
*****************************************************************************************




















===================================================================================
üß™ Lab 1 ‚Äì Exploring Traditional vs. Automated Configuration

Topic: Manual Setup vs. Scripted (Automated) Setup
===================================================================================


üß† 1. Concept Overview
System Configuration refers to the process of setting up servers, installing software, 
and ensuring services are running correctly.



There are two major approaches to doing this:
      Traditional (Manual) Configuration
                  Admins perform setup tasks manually using terminal commands 
                  or GUIs on each system individually.
      
      Automated Configuration
                  Configuration tasks are written as scripts or playbooks and 
                  executed automatically across multiple systems using tools 
                  like Ansible, Puppet, or Chef.





‚öôÔ∏è 2. Traditional (Manual) Configuration
üîπ Characteristics
            Admin connects to each machine using SSH.
            Runs commands one by one.
            Configurations vary if any step is missed.
            Time-consuming for large environments.

üßæ Example ‚Äî Manual Apache Installation
      
      Let‚Äôs say an admin wants to install and start Apache HTTP Server on 3 servers.

                        # Run on every server manually
                        sudo apt update -y
                        sudo apt install apache2 -y
                        sudo systemctl enable apache2
                        sudo systemctl start apache2
                        sudo systemctl status apache2
      
      
                  ‚ö†Ô∏è Drawbacks
                  Must repeat on each node individually.
                  Prone to human error (typos, missed commands).
                  Difficult to maintain consistent configuration.
                  No audit trail or change versioning.







ü§ñ 3. Automated Configuration

Automation means using a tool or script to apply configurations 
consistently and repeatedly across all systems.

Tools like Ansible allow central management using YAML-based Playbooks.

üîπ How It Works (Ansible Example)
            Admin defines tasks in a YAML file (Playbook).
            Ansible connects via SSH to all target hosts (no agents needed).
            Executes the same configuration steps automatically.


üßæ Example ‚Äî Automated Apache Installation Using Ansible
      File: install_apache.yml

                  - name: Install and Start Apache Web Server
                    hosts: webservers
                    become: yes
                    tasks:
                      - name: Install Apache package
                        apt:
                          name: apache2
                          state: present
                  
                      - name: Ensure Apache is running
                        service:
                          name: apache2
                          state: started
                          enabled: yes
                  


            Run it with:
                  ansible-playbook -i inventory install_apache.yml



            ‚úÖ Advantages
                        One command manages all servers.
                        Idempotent: if Apache is already installed, it won‚Äôt reinstall.
                        Logs and reports are stored centrally.
                        Scalable: works on 10 or 10,000 servers identically.
                        




‚öñÔ∏è 4. Comparison: Manual vs. Automated Configuration

      | **Aspect**           | **Manual (Traditional)**   | **Automated (Using Ansible)**    |
      | -------------------- | -------------------------- | -------------------------------- |
      | **Execution Method** | Commands run manually      | Playbook runs via Ansible        |
      | **Consistency**      | May vary per admin or host | Guaranteed identical setup       |
      | **Scalability**      | Limited to few servers     | Manages hundreds easily          |
      | **Error Handling**   | Manual checking            | Automated logs & error reports   |
      | **Reusability**      | Repeated typing            | Reusable playbooks               |
      | **Change Tracking**  | None                       | Version-controlled (Git)         |
      | **Security**         | Depends on user discipline | Controlled via Vaults & Policies |



üß© 5. Real-Life Analogy

      Manual configuration = Cooking every dish from scratch each time.
      
      Automated configuration = Having a recipe (playbook) and a chef (Ansible) who
                                prepares identical dishes consistently every time.




‚úÖ Example Summary Output (When Using Ansible)

            PLAY [Install and Start Apache Web Server] ************************************
            
            TASK [Install Apache package] *************************************************
            changed: [192.168.10.120]
            changed: [192.168.10.121]
            
            TASK [Ensure Apache is running] ***********************************************
            ok: [192.168.10.120]
            ok: [192.168.10.121]
            
            PLAY RECAP ********************************************************************
            192.168.10.120      : ok=2 changed=1
            192.168.10.121      : ok=2 changed=1


      ‚úÖ Both servers are configured automatically ‚Äî consistent, fast, and logged.
















===================================================================================
üß© Lab 2 ‚Äì Understanding Automation Tools: Comparing Ansible, Puppet, Chef, and SaltStack

(Feature Exploration and Conceptual Understanding)
===================================================================================




            Ansible‚Äôs agentless, YAML-driven, push-based design makes it ideal for 
            today‚Äôs cloud, DevOps, and hybrid infrastructures, offering rapid 
            automation without the overhead of maintaining agents or mastering complex DSLs.





üéØ Objective

            To understand the key automation and configuration management tools used in
            modern IT environments, explore their architectural differences, and analyze
            why Ansible has become one of the most popular choices.
            


üß† 1. Concept Overview

      üîπ What is Configuration Management?
            Configuration management (CM) ensures systems maintain a 
            desired state ‚Äî specific versions of software, packages, and
            services ‚Äî across multiple machines.
      
            Instead of configuring servers manually, CM tools automate this
            process, ensuring consistency and reducing human error.



üß∞ 2. Major Automation Tools

      The four most widely used tools in the DevOps ecosystem are:

            Ansible ‚Äì Agentless, simple, and YAML-based.
            
            Puppet ‚Äì Mature enterprise tool using its own declarative DSL (Ruby-like).
            
            Chef ‚Äì Ruby-based, developer-oriented configuration management system.
            
            SaltStack ‚Äì Event-driven automation using Python and YAML (now part of VMware).



‚öôÔ∏è 3. Architecture Comparison

| **Feature / Aspect**  | **Ansible**                              | **Puppet**                      | **Chef**                         | **SaltStack**                     |
| --------------------- | ---------------------------------------- | ------------------------------- | -------------------------------- | --------------------------------- |
| **Language / Syntax** | YAML (Playbooks)                         | Puppet DSL (Ruby-style)         | Ruby                             | YAML (SLS files)                  |
| **Architecture Type** | **Agentless** (uses SSH)                 | Master‚ÄìAgent                    | Server‚ÄìClient                    | Master‚ÄìMinion (or agentless mode) |
| **Execution Model**   | Push-based (control node triggers tasks) | Pull-based (agent polls master) | Pull-based                       | Push / Pull both                  |
| **Ease of Setup**     | ‚≠ê Very easy                             | Moderate                        | Complex                          | Moderate                          |
| **Learning Curve**    | Low                                      | Medium                          | High                             | Medium                            |
| **Platform Support**  | Linux, Windows, macOS                    | Linux, Windows                  | Linux, Windows                   | Linux, Windows                    |
| **Community Support** | Very Large & Active                      | Mature & Stable                 | Strong DevOps Community          | Moderate (enterprise focus)       |
| **Best Use Case**     | Fast deployment, multi-cloud automation  | Policy-driven infra enforcement | Complex pipelines and compliance | Real-time event-driven ops        |
| **Agent Requirement** | ‚ùå None (agentless SSH)                   | ‚úÖ Yes                           | ‚úÖ Yes                            | Optional (Minion or SSH)          |
| **Primary Strength**  | Simplicity & Speed                       | Enterprise compliance           | Flexibility & integration        | Real-time communication           |








üß© 4. Workflow Example
            üü© Ansible (Agentless Automation)
            
                        - name: Install Apache using Ansible
                          hosts: webservers
                          become: yes
                          tasks:
                            - name: Ensure Apache is installed
                              apt:
                                name: apache2
                                state: present


            ‚û°Ô∏è Run via ansible-playbook -i inventory apache.yml
            
            Communication: Over SSH ‚Äî no agent required.
      







            üü® Puppet (Master‚ÄìAgent Model)
            
            You define a manifest in Ruby-style DSL:
            
            
                        package { 'httpd':
                          ensure => installed,
                        }
                        service { 'httpd':
                          ensure => running,
                        }




            ‚û°Ô∏è The Puppet Agent periodically contacts the Puppet
                Master for configuration updates










            üü• Chef (Client‚ÄìServer Model)
                        
                        Recipes written in Ruby, grouped in cookbooks:
                        
                        
                                    package 'httpd' do
                                      action :install
                                    end
                                    
                                    service 'httpd' do
                                      action [:enable, :start]
                                    end
                        
                        
            Chef Client pulls instructions from the Chef Server.







            üü¶ SaltStack (Event-Driven Automation)
            
                              Uses States (SLS files) written in YAML:
                              
                                                
                                                apache:
                                                  pkg.installed
                                                  service.running:
                                                    - enable: true
                              
            Can operate push (via Salt master) or pull (via minions).
            















üß© 5. Practical Use Comparison


| **Scenario**                                           | **Preferred Tool** | **Reason**                                 |
| ------------------------------------------------------ | ------------------ | ------------------------------------------ |
| Quick multi-server deployment                          | **Ansible**        | Agentless, simple playbooks                |
| Large regulated enterprise with compliance policies    | **Puppet**         | Centralized master with policy enforcement |
| DevOps pipeline with heavy Ruby integration            | **Chef**           | Deep Ruby customization                    |
| Real-time event-driven automation (SD-WAN, networking) | **SaltStack**      | Event bus and fast execution               |








‚ö° 6. Key Differences at a Glance

| Category | Agentless | Language Simplicity | Speed (Initial Use) | Cloud Integration |
|---------------|----------------|--------------------------|--------------------------|
| Ansible | ‚úÖ Yes | ‚≠ê YAML (Easy) | ‚≠ê‚≠ê‚≠ê‚≠ê | AWS, Azure, GCP Modules |
| Puppet | ‚ùå No | Medium | ‚≠ê‚≠ê‚≠ê | AWS, VMware Plugins |
| Chef | ‚ùå No | Complex (Ruby) | ‚≠ê‚≠ê | AWS SDK Integration |
| SaltStack | Optional | Medium (YAML) | ‚≠ê‚≠ê‚≠ê‚≠ê | Good via event system |










üîê 7. Why Ansible Stands Out
            
            ‚úÖ Agentless ‚Äî simpler, fewer security issues.
            ‚úÖ Human-readable YAML ‚Äî no programming background required.
            ‚úÖ Push-based execution ‚Äî instant configuration updates.
            ‚úÖ Modular ecosystem ‚Äî thousands of ready-to-use modules.
            ‚úÖ Strong community support ‚Äî Red Hat backed, widely adopted.
            



üß† 8. Key Takeaways

            All CM tools aim to enforce consistency and automation.
            Puppet and Chef are older, agent-based, and suited for large legacy systems.
            Ansible provides simplicity, agentless operation, and faster adoption.
            SaltStack adds flexibility for event-driven, near real-time automation.
            Choosing a tool depends on team skill set, environment size, and governance needs.
            
            











===================================================================================
EXTRA - Proxmox setup
===================================================================================

üß± 1. Understanding Proxmox CTs

                  When you create a CT (Container) in Proxmox using templates like
                  
                                    centos-9-stream-default_2025-xx-xx.txz,
                                    
                                    ubuntu-22.04-default_2025-xx-xx.tzst,
                  
                  
                  
                  you are creating LXC containers ‚Äî lightweight, isolated Linux 
                  environments that share the Proxmox host kernel.
                  
                  
                  
                  ‚û°Ô∏è These CTs behave like full Linux servers (with shell access, 
                  networking, and package managers) ‚Äî perfect for Ansible testing.
                  
                  They use fewer resources than full VMs and support SSH, Python, and 
                  systemd ‚Äî exactly what Ansible needs.



‚öôÔ∏è 2. Feasibility for Your Lab Simulation

      Yes ‚úÖ ‚Äî this setup is ideal for your Ansible lab:


| **Role**                  | **Container Name** | **Template / OS**                       | **Example IP** | **Purpose**  |
| ------------------------- | ------------------ | --------------------------------------- | -------------- | ------------ |
| **Master / Control Node** | `centos1`          | CentOS Stream 9 (`centos-9-stream.txz`) | 192.168.10.100 | Runs Ansible |
| **Node 2**                | `centos2`          | CentOS Stream 9 (`centos-9-stream.txz`) | 192.168.10.110 | Managed node |
| **Node 3**                | `ubuntu1`          | Ubuntu 22.04 (`ubuntu-22.04.tzst`)      | 192.168.10.120 | Managed node |






‚úÖ This architecture is perfectly valid ‚Äî Ansible is cross-platform
and can manage mixed environments.






üß™ 3. Compatibility Verification


| **Requirement**  | **CT Support**                                                    | **Status** |
| ---------------- | ----------------------------------------------------------------- | ---------- |
| Linux OS         | ‚úîÔ∏è Supported (CentOS, Ubuntu, Fedora)                             |            |
| Python installed | ‚úîÔ∏è Required on managed nodes                                      |            |
| SSH access       | ‚úîÔ∏è Works normally in CTs                                          |            |
| Systemd          | ‚úîÔ∏è Works in most LXC templates (except minimal images)            |            |
| Networking       | ‚úîÔ∏è CTs can use `vmbr0` or NAT bridge ‚Äî same subnet for simplicity |            |


            üü° Note: If SSH or Python isn‚Äôt installed by default in
                the CT template, you‚Äôll just install them once manually:


                                    # For CentOS
                                    dnf install -y python3 openssh-server
                                    systemctl enable --now sshd
                                    
                                    # For Ubuntu
                                    apt update -y
                                    apt install -y python3 openssh-server
                                    systemctl enable --now ssh
                                    








‚öôÔ∏è Ansible Lab Hardware Requirements (Proxmox Container Setup)


| **Node Name** | **OS Template**          | **IP Address** | **vCPU** | **RAM** | **Role**       |
| ------------- | ------------------------ | -------------- | -------- | ------- | -------------- |
| `centos1`     | CentOS Stream 9 (`.txz`) | 192.168.10.100 | 4        | 4 GB    | Ansible Master |
| `centos2`     | CentOS Stream 9 (`.txz`) | 192.168.10.110 | 2        | 2 GB    | Managed Node 1 |
| `ubuntu1`     | Ubuntu 22.04 (`.tzst`)   | 192.168.10.120 | 2        | 2 GB    | Managed Node 2 |






üß† 2. Key System Prerequisites

| **Component**           | **Requirement**                                                                         |
| ----------------------- | --------------------------------------------------------------------------------------- |
| **Python 3**            | Must be installed on all managed nodes (Ansible relies on Python for module execution). |
| **SSH Service**         | Required for master ‚Üî slave communication (`openssh-server` must be running).           |
| **Network**             | All nodes must be on **the same network bridge** (e.g., `vmbr0`) and reachable by IP.   |
| **Hostname Resolution** | Optionally configure `/etc/hosts` or local DNS for easier management.                   |
| **Root Access**         | Simplifies lab setup (can later switch to sudo users).                                  |



MAIN LAB
------------------------------------------

| **Node**              | **Hostname**     | **IP Address** | **Role / Purpose**                             |
| --------------------- | ---------------- | -------------- | ---------------------------------------------- |
| üè∞ **ansible-master** | `ansible-master` | `192.168.5.80` | Control Node (where Ansible will be installed) |
| üíª **centos-node1**   | `centos-node1`   | `192.168.5.81` | Managed Node 1 (CentOS target)                 |
| üíª **ubuntu-node2**   | `ubuntu-node2`   | `192.168.5.83` | Managed Node 2 (Ubuntu target)                 |



===================================================================================

===================================================================================









===================================================================================

===================================================================================









===================================================================================

===================================================================================









===================================================================================

===================================================================================









===================================================================================

===================================================================================









===================================================================================

===================================================================================




